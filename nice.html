<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="icon" type="image/x-icon" href="https://codehs.com/uploads/909e95c2c5ff974e28ead8fd55d7b386">
    <title>Chat+</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #36393f; color: #dcddde; height: 100vh; overflow: hidden;
        }
        .app-container { display:flex; height:100vh; }
        .server-sidebar { width:72px; background:#202225; display:flex; flex-direction:column; align-items:center; padding:12px 0; }
        .nav-item { width:48px; height:48px; border-radius:50%; display:flex; align-items:center; justify-content:center; cursor:pointer; transition:border-radius .2s; margin-bottom:8px; position:relative; }
        .nav-item:hover { border-radius:16px; }
        .nav-item.active { background:#5865f2; }
        .nav-item:not(.active) { background:#36393f; }
        /* Prevent mobile browsers from auto-zooming text when inputs are focused */
        html, body { -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; }
        
        /* Ensure modal/input font sizes are >= 16px so iOS won't zoom on focus */
        .modal-input, input.message-input, input.modal-input, textarea.modal-input {
          font-size: 16px;
        }


        .channel-sidebar { width:240px; background:#2f3136; display:flex; flex-direction:column; }
        .channel-header { padding:16px; border-bottom:1px solid #202225; font-weight:600; font-size:16px; }
        .channel-list { flex:1; overflow-y:auto; padding:16px 8px; }
        .channel-item { padding:8px 12px; margin-bottom:2px; border-radius:4px; cursor:pointer; display:flex; align-items:center; transition:background .1s; }
        .channel-item:hover { background:#34373c; }
        .channel-item.active { background:#393c43; }

        .friends-list-view { flex:1; overflow-y:auto; padding:16px; }
        .friends-section { margin-bottom:24px; }
        .friends-section-title { font-size:12px; text-transform:uppercase; color:#8a8d91; margin-bottom:8px; font-weight:600; }
        .dm-friend-item { padding:8px 12px; border-radius:4px; cursor:pointer; display:flex; align-items:center; margin-bottom:2px; transition:background .1s; }
        .dm-friend-item:hover { background:#34373c; }
        .dm-friend-item.active { background:#393c43; }
        .dm-friend-avatar { width:32px; height:32px; border-radius:50%; background:#5865f2; margin-right:12px; position:relative; }
        .dm-status-indicator { position:absolute; bottom:0; right:0; width:10px; height:10px; border-radius:50%; border:2px solid #2f3136; }
        .dm-friend-name { flex:1; }
        .unread-badge { background:#f9a62b; color:white; padding:2px 6px; border-radius:10px; font-size:12px; font-weight:600; }

        .main-content { flex:1; display:flex; flex-direction:column; background:#36393f; }
        .chat-header { height:48px; border-bottom:1px solid #202225; display:flex; align-items:center; padding:0 16px; }
        .channel-name { font-weight:600; font-size:16px; }
        .chat-area { flex:1; display:flex; }
        .messages-container { flex:1; display:flex; flex-direction:column; }
        .messages { flex:1; overflow-y:auto; padding:16px; }
        .message { margin-bottom:16px; display:flex; }
        .message-avatar { width:40px; height:40px; border-radius:50%; background:#5865f2; margin-right:16px; flex-shrink:0; }
        .message-content { flex:1; }
        .message-header { display:flex; align-items:baseline; margin-bottom:4px; }
        .message-author { font-weight:500; margin-right:8px; }
        .message-time { font-size:12px; color:#72767d; }
        .message-text { color:#dcddde; line-height:1.375; }
        .message-input-container { padding:0 16px 24px; display:flex; align-items:center; gap:8px; }
        .message-input { flex:1; background:#40444b; border:none; border-radius:8px; padding:12px 16px; color:#dcddde; font-size:16px; outline:none; }
        /* Scrollbar styling for .messages */
.messages::-webkit-scrollbar {
  width: 10px;
}

.messages::-webkit-scrollbar-track {
  background: #2f3136;
  border-radius: 8px;
}

.messages::-webkit-scrollbar-thumb {
  background: #5865f2;
  border-radius: 8px;
  transition: background 0.3s ease;
}

.messages::-webkit-scrollbar-thumb:hover {
  background: #4752c4;
}


        
        .app-container,
.main-content,
.chat-area,
.messages-container {
  min-height: 0;   /* <-- key to let flex children shrink */
  min-width: 0;    /* already added in parts, safe to include */
}

/* messages area should be the scrollable element */
.messages {
  flex: 1;
  min-height: 0;                  /* <-- important */
  overflow-y: auto;               /* enable vertical scroll */
  overflow-x: hidden;
  -webkit-overflow-scrolling: touch; /* smooth scrolling on iOS */
  padding: 16px;
  word-wrap: break-word;
}

/* make sure fixed-width sidebars don't shrink */
.server-sidebar,
.channel-sidebar,
.right-sidebar {
  flex-shrink: 0;
}

/* Optional: keep the message input always visible (sticky) */
.message-input-container {
  /* either keep as part of layout, or use sticky to pin it to bottom */
  /* uncomment to use sticky: */
  /* position: sticky; */
  /* bottom: 0; */
  /* background: linear-gradient(rgba(54,57,63,0), rgba(54,57,63,1)); */
  padding: 0 16px 24px;
  display: flex;
  align-items: center;
  gap: 8px;
  z-index: 10;
}

/* Prevent long unbroken strings from expanding layout */
.messages,
.message-text {
  word-break: break-word;
  overflow-wrap: anywhere;
}

        .user-profile { height:52px; background:#292b2f; display:flex; align-items:center; padding:0 8px; border-top:1px solid #202225; }
        .user-avatar { width:32px; height:32px; border-radius:50%; background:#5865f2; margin-right:8px; cursor:pointer; }
        .user-info { flex:1; }
        .username { font-size:14px; font-weight:500; }
        .user-id { font-size:12px; color:#b9bbbe; }
        .settings-btn { background:none; border:none; color:#b9bbbe; cursor:pointer; padding:4px; border-radius:4px; transition:color .2s; }
        .settings-btn:hover { color:#dcddde; }

        /* Right sidebar (users list) */
        .right-sidebar {
            width: 320px;
            background: #2b2d31;
            border-left: 1px solid #202225;
            display:flex;
            flex-direction:column;
            transition: transform .25s ease;
            transform: translateX(0);
            z-index: 50;
        }
        .right-sidebar.hidden { transform: translateX(100%); }
        .right-header { padding:12px 16px; border-bottom:1px solid #202225; display:flex; align-items:center; justify-content:space-between; }
        .right-body { flex:1; overflow:auto; padding:12px; }
        .user-row { display:flex; align-items:center; gap:10px; padding:8px;border-radius:6px; cursor:pointer; }
        .user-row:hover { background:#34373c; }
        .user-row .avatar { width:36px;height:36px;border-radius:50%;background:#5865f2;position:relative; }
        .user-row .status { position:absolute; right:-2px; bottom:-2px; width:10px;height:10px;border-radius:50%; border:2px solid #2b2d31; }
        .user-meta { flex:1; }
        .user-name { font-weight:600; }
        .user-sub { font-size:12px;color:#9a9da0; }

        .toggle-right-btn { position: absolute; right: -26px; top: 12px; width:24px;height:24px;background:#202225;border-radius:6px;display:flex;align-items:center;justify-content:center;cursor:pointer;border:2px solid #202225; }
        .typing-dot { width:8px;height:8px;border-radius:50%;background:#9ae6b4;margin-left:6px; }

        /* Friend requests mini panel */
/* ---------- Improved Friend Requests Panel ---------- */
.friend-requests-panel {
  position: absolute;
  left: 72px; /* just right of server sidebar */
  top: 80px;
  width: 320px;
  max-width: calc(100vw - 96px);
  max-height: 60vh;
  background: linear-gradient(180deg, #2f3136 0%, #292a2d 100%);
  border: 1px solid rgba(24,26,28,0.6);
  border-radius: 12px;
  z-index: 1200;
  box-shadow: 0 10px 30px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
  display: none;
  padding: 12px;
  overflow: hidden;
  backdrop-filter: blur(6px);
}

/* show + subtle pop */
.friend-requests-panel.open {
  display: block;
  animation: fr-pop .12s cubic-bezier(.2,.9,.3,1);
}

/* Message delete button */
.message-actions {
  display:flex;
  gap:8px;
  margin-top:8px;
  align-items:center;
}
.message-delete-btn {
  height:28px;
  padding:6px 8px;
  border-radius:6px;
  border:none;
  cursor:pointer;
  background: rgba(255,80,80,0.12);
  color: #ff9b9b;
  font-weight:700;
}
.message-delete-btn:hover {
  background: rgba(255,80,80,0.18);
  color:#ff7171;
}
.message-deleting {
  transition: opacity .22s ease, transform .22s ease, height .22s ease, margin .22s ease, padding .22s ease;
  opacity: .0;
  transform: scale(.98);
  height:0 !important;
  margin:0 !important;
  padding:0 !important;
}


.friend-requests-panel h4 {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  font-weight: 700;
  font-size: 14px;
  color: #e6e6e6;
  margin-bottom: 10px;
  padding-right: 6px;
}

.friend-requests-panel .fr-count {
  display: inline-block;
  min-width: 28px;
  padding: 4px 8px;
  border-radius: 999px;
  background: linear-gradient(90deg,#5865f2,#7b8aff);
  color: #fff;
  font-size: 12px;
  font-weight: 700;
  text-align: center;
  box-shadow: 0 2px 6px rgba(88,101,242,0.18);
}

/* Star overlay on message GIFs */
.message-img-wrapper { position: relative; display: inline-block; border-radius: 8px; overflow: visible; }
.message .message-image { display: block; width: 100%; height: auto; border-radius: 8px; object-fit: contain; } /* don't crop */
.message-gif-fav-star {
  position: absolute;
  top: 6px;
  right: 6px;
  width: 30px;
  height: 30px;
  border-radius: 8px;
  display:flex;
  align-items:center;
  justify-content:center;
  background: rgba(0,0,0,0.45);
  color: #fff;
  font-size: 16px;
  cursor: pointer;
  z-index: 20;
  border: 1px solid rgba(255,255,255,0.04);
  user-select: none;
}
.message-gif-fav-star.favorited {
  background: linear-gradient(90deg,#f9d423,#ff6b6b);
  color: #222;
  box-shadow: 0 6px 18px rgba(255,107,107,0.12);
}


/* embedded images / gifs inside messages */
.message-embed {
  max-width: 360px;
  max-height: 360px;
  display: block;
  margin-top: 8px;
  border-radius: 8px;
  object-fit: cover;
  cursor: pointer;
  box-shadow: 0 6px 18px rgba(0,0,0,0.45);
}

/* clickable small link pill for non-image URLs */
.message-link {
  display:inline-block;
  margin-left:6px;
  margin-top:6px;
  padding:6px 10px;
  border-radius:8px;
  background: rgba(255,255,255,0.03);
  color: #e6e6e6;
  font-weight:700;
  font-size:13px;
  text-decoration:none;
  border: 1px solid rgba(255,255,255,0.03);
}
.message-link:hover { transform: translateY(-1px); box-shadow: 0 6px 16px rgba(0,0,0,0.35); }


/* scroll area */
#frList {
  max-height: calc(60vh - 72px);
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding-right: 6px;
}

/* individual request card */
.fr-item {
  display: flex;
  gap: 12px;
  align-items: center;
  justify-content: space-between;
  padding: 10px;
  border-radius: 10px;
  background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0));
  transition: transform .12s ease, background .12s ease, box-shadow .12s ease;
  box-shadow: 0 2px 8px rgba(0,0,0,0.35);
  border: 1px solid rgba(255,255,255,0.02);
}

/* tiny hover lift */
.fr-item:hover {
  transform: translateY(-4px);
  background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.005));
}

/* left content */
.fr-left {
  display:flex;
  gap:10px;
  align-items:center;
  min-width: 0; /* allow ellipsis on name */
}

/* Favorites submenu (popup) */
.gif-favs-submenu {
  position: fixed;
  z-index: 1400;
  background: #2f3136;
  border: 1px solid #202225;
  padding: 10px;
  border-radius: 10px;
  width: min(720px, 92vw);
  max-height: 64vh;
  display: none; /* toggled via JS */
  flex-direction: column;
  gap: 8px;
  box-shadow: 0 12px 36px rgba(0,0,0,0.6);
  overflow: hidden;
}

.gif-favs-submenu .favs-header {
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
  padding-bottom:6px;
  border-bottom: 1px solid rgba(255,255,255,0.03);
}

.gif-favs-submenu .favs-title { font-weight:700; color:#e6e6e6; }

.gif-favs-submenu .favs-actions { display:flex; gap:8px; align-items:center; }

.gif-favs-list {
  overflow:auto;
  padding:8px 2px 2px 2px;
  display:grid;
  gap:8px;
  /* one column on narrow, two columns on wider screens */
  grid-template-columns: 1fr;
}

@media (min-width:740px){
  .gif-favs-list { grid-template-columns: repeat(2, 1fr); }
}

/* Each favorite item: container keeps natural aspect ratio by letting image size itself.
   img uses object-fit: contain and width:100% so it's never cropped. */
.gif-fav-item {
  background: transparent;
  border-radius: 8px;
  padding: 6px;
  display:flex;
  align-items:center;
  justify-content:center;
  gap:8px;
}

.gif-fav-item img {
  width: 100%;
  height: auto;
  max-height: 40vh; /* cap to submenu height */
  object-fit: contain; /* DO NOT crop */
  border-radius: 6px;
  display:block;
}

/* small caption row under each gif (optional) */
.gif-fav-meta { font-size:12px; color:#9a9da0; margin-top:6px; }

/* empty state */
.gif-favs-empty { padding:18px; color:#9a9da0; text-align:center; }


.fr-avatar {
  width:44px;
  height:44px;
  border-radius:50%;
  background: #5865f2;
  display:flex;
  align-items:center;
  justify-content:center;
  color:white;
  font-weight:700;
  font-size:14px;
  flex-shrink:0;
  box-shadow: inset 0 -2px 6px rgba(0,0,0,0.25);
}

.fr-meta {
  display:flex;
  flex-direction:column;
  min-width: 0;
}

.fr-name {
  font-weight:700;
  font-size:14px;
  color:#ffffff;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}

.fr-time {
  margin-top:4px;
  font-size:12px;
  color:#9a9da0;
}

/* actions */
.fr-actions {
  display:flex;
  gap:8px;
  align-items:center;
}

.fr-actions button {
  height:34px;
  padding:6px 10px;
  border-radius:8px;
  border:none;
  cursor:pointer;
  font-weight:700;
  font-size:13px;
  transition: transform .08s ease;
}

.fr-actions button:active { transform: scale(.98); }

/* accept (primary) */
.fr-accept {
  background: linear-gradient(90deg,#5b6ff9,#7c9bff);
  color: #fff;
  box-shadow: 0 6px 18px rgba(92,99,255,0.12);
}

/* ignore / decline (secondary) */
.fr-ignore {
  background: transparent;
  color: #d1d3d5;
  border: 1px solid rgba(255,255,255,0.04);
}

/* nice empty state */
.friend-requests-panel .no-requests {
  color: #9a9da0;
  text-align:center;
  padding:18px 6px;
  font-size:13px;
}

/* animate enter/exit (apply css classes from JS if desired) */
@keyframes fr-pop {
  from { transform: translateY(-6px) scale(.98); opacity: 0 }
  to   { transform: translateY(0) scale(1); opacity: 1 }
}

/* custom scrollbar for panel */
#frList::-webkit-scrollbar { width: 8px; }
#frList::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.04); border-radius: 8px; }
#frList::-webkit-scrollbar-track { background: transparent; }

/* responsive tweaks */
@media (max-width:420px){
  .friend-requests-panel { left: 12px; width: calc(100% - 24px); top: 72px; }
  .fr-avatar { width:40px; height:40px; font-size:13px; }
}

        .fr-item { display:flex; align-items:center; justify-content:space-between; padding:8px; border-radius:6px; }
        .fr-item + .fr-item { margin-top:6px; }
        .fr-actions { display:flex; gap:8px; }

        .typing-indicator { font-size:13px; color:#9ae6b4; padding:8px 0 10px 0; display:flex; align-items:center; gap:8px; }

/* reactions styles */
.reactions { display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; }
.reaction-btn { display:inline-flex; align-items:center; gap:6px; padding:6px 8px; border-radius:14px; background:#2f3136; color:#fff; border:none; cursor:pointer; font-size:13px; }
.reaction-btn.own { outline:2px solid rgba(88,101,242,0.18); }

.emoji-picker-popup { position:fixed; z-index:1201; background:#2f3136; border:1px solid #202225; padding:8px; border-radius:8px; display:flex; gap:6px; flex-wrap:wrap; max-width:320px; box-shadow:0 8px 24px rgba(0,0,0,.6); }
.emoji-cell { font-size:18px; padding:6px; cursor:pointer; border-radius:6px; }
.emoji-cell:hover { background:#34373c; }

.message-image { max-width:320px; max-height:320px; display:block; margin-top:8px; border-radius:8px; }

/* --- Flex shrink fixes: allow center column to shrink instead of pushing sidebars --- */
/* let the main content and inner message containers be able to shrink */
.main-content,
.messages-container,
.messages {
  min-width: 0; /* allow these flex items to shrink below their content width */
}

/* keep fixed-width sidebars fixed and not squished */
.server-sidebar,
.channel-sidebar,
.right-sidebar {
  flex-shrink: 0;
}


/* GIF picker styles */
.gif-picker-popup {
  position: fixed;
  z-index: 1300;
  background: #2f3136;
  border: 1px solid #202225;
  padding: 10px;
  border-radius: 10px;
  width: min(760px, 92vw);
  max-height: 64vh;
  display: flex;
  flex-direction: column;
  gap: 8px;
  box-shadow: 0 12px 36px rgba(0,0,0,0.6);
}

.gif-picker-top {
  display:flex;
  gap:8px;
  align-items:center;
}

.gif-favs-strip {
  display:flex;
  gap:8px;
  overflow-x:auto;
  padding:6px 4px;
  border-radius:8px;
  background: linear-gradient(90deg, rgba(255,255,255,0.01), transparent);
  max-width: 100%;
}

.gif-fav-thumb {
  width:72px;
  height:48px;
  border-radius:6px;
  flex: 0 0 auto;
  position:relative;
  cursor:pointer;
  overflow:hidden;
  display:inline-block;
}
.gif-fav-thumb img { width:100%; height:100%; object-fit:cover; display:block; }

.gif-search {
  flex:1;
  display:flex;
  gap:8px;
}

.gif-search input {
  flex:1;
  padding:8px 10px;
  border-radius:8px;
  border:1px solid rgba(255,255,255,0.04);
  background:#202225;
  color:#e6e6e6;
  outline:none;
}

.gif-tabs {
  display:flex;
  gap:8px;
  align-items:center;
}

.gif-grid {
  display:grid;
  grid-template-columns: repeat(auto-fill,minmax(140px,1fr));
  gap:8px;
  overflow:auto;
  padding:6px;
  border-radius:8px;
  background: transparent;
  flex:1;
}

.gif-thumb {
  position:relative;
  border-radius:8px;
  overflow:hidden;
  background:#1f2022;
  min-height:80px;
  cursor:pointer;
  display:flex;
  align-items:center;
  justify-content:center;
}

.gif-thumb img { width:100%; height:100%; object-fit:cover; display:block; }

.gif-thumb .gif-meta {
  position:absolute;
  left:8px;
  bottom:8px;
  font-size:12px;
  color:#fff;
  background: rgba(0,0,0,0.35);
  padding:4px 6px;
  border-radius:6px;
}

/* user search input in left sidebar */
.user-search-row { background: transparent; }
.user-search-input {
  width:100%;
  padding:8px 10px;
  border-radius:8px;
  border:1px solid rgba(255,255,255,0.03);
  background:#202225;
  color:#e6e6e6;
  outline:none;
  font-size:14px;
}
.user-search-input::placeholder { color:#7f8287; }

/* highlight matched text */
.search-match {
  background: rgba(88,101,242,0.16);
  padding: 2px 4px;
  border-radius: 4px;
  font-weight:700;
  color: inherit;
}

/* Right-sidebar user search */
.right-user-search-input {
  padding:6px 8px;
  border-radius:8px;
  border:1px solid rgba(255,255,255,0.03);
  background:#202225;
  color:#e6e6e6;
  outline:none;
  font-size:13px;
  min-width:160px;
}
.right-user-search-input::placeholder { color:#7f8287; }

/* Highlight matched substring */
.right-search-match {
  background: rgba(88,101,242,0.16);
  padding: 2px 4px;
  border-radius: 4px;
  font-weight:700;
  color: inherit;
}

/* star button at top-right of each gif (fav/unfav) */
.gif-fav-star {
  position: absolute;
  top:6px;
  right:6px;
  width:28px;
  height:28px;
  border-radius:6px;
  display:flex;
  align-items:center;
  justify-content:center;
  background: rgba(0,0,0,0.35);
  color: #fff;
  font-size:16px;
  cursor:pointer;
  z-index:5;
  border: 1px solid rgba(255,255,255,0.04);
}
.gif-fav-star.favorited {
  background: linear-gradient(90deg,#f9d423,#ff6b6b);
  color: #222;
  box-shadow: 0 6px 18px rgba(255,107,107,0.12);
}

/* small helper for empty favourite state */
.gif-picker-empty {
  padding:18px;
  color:#9a9da0;
  text-align:center;
}

/* keep gif picker responsive */
@media (max-width:560px){
  .gif-grid { grid-template-columns: repeat(auto-fill,minmax(120px,1fr)); }
  .gif-fav-thumb { width:56px; height:40px; }
}




/* avoid horizontal overflow inside messages */
.messages {
  overflow-x: hidden; /* prevent long content from forcing horizontal grow */
  word-wrap: break-word; /* break long words/URLs so they don't expand the container */
}
        /* Modal */
        .modal { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.5); z-index:1000; align-items:center; justify-content:center; }
        .modal-content { background:#36393f; border-radius:8px; padding:24px; width:400px; box-shadow:0 4px 12px rgba(0,0,0,.5); }
        .modal-header { font-size:20px; font-weight:600; margin-bottom:16px; }
        .modal-input { width:100%; background:#202225; border:none; border-radius:4px; padding:12px; color:#dcddde; margin-bottom:8px; outline:none; }
        .modal-buttons { display:flex; justify-content:flex-end; gap:8px; margin-top:12px; }
        .modal-btn { padding:8px 16px; border:none; border-radius:4px; cursor:pointer; font-weight:500; }
        .modal-btn-primary { background:#5865f2; color:white; }
        .modal-btn-secondary { background:#4f545c; color:white; }

        .error { color:#ff6b6b; font-size:13px; margin-top:6px; }
        .success { color:#6be58a; font-size:13px; margin-top:6px; }
        .row { display:flex; gap:8px; align-items:center; }
        .flex-1 { flex:1; }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Server Sidebar -->
        <div class="server-sidebar">
            <div class="nav-item active" onclick="showFriendsList()" title="Direct Messages" id="navDM">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="white"><path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"/></svg>
            </div>
            <div class="nav-item" onclick="showServerChannels()" title="Main Server" id="navServer">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="white"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>
            </div>

            <!-- Friend Requests mini-panel toggle -->
            <div class="nav-item" onclick="toggleFriendRequests()" title="Friend Requests" id="navFR">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="white"><path d="M12 12c2.21 0 4-1.79 4-4S14.21 4 12 4 8 5.79 8 8s1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>
            </div>

            <!-- toggle for right sidebar -->
            <div style="margin-top:auto;padding-bottom:8px;position:relative;">
                <div id="toggleRight" class="nav-item" title="Users (open/close)" onclick="toggleRightSidebar()" style="width:48px;height:48px;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="white"><path d="M3 13h2v-2H3v2zm4 0h10v-2H7v2zM3 17h2v-2H3v2zm0-8h2V7H3v2zm4 0h10V7H7v2z"/></svg>
                </div>
            </div>
        </div>

        <!-- Channel Sidebar -->
        <div class="channel-sidebar">
            <div class="channel-header" id="sidebarHeader">Direct Messages</div>

<!-- USER SEARCH (left sidebar) -->
<div class="user-search-row" style="padding:8px 12px;border-bottom:1px solid rgba(0,0,0,0.06);">
  <div style="display:flex;align-items:center;gap:8px;width:100%;">
    <input id="userSearchInput" type="search" placeholder="Search users" class="user-search-input" aria-label="Search users" />
    <button id="clearUserSearchBtn" class="modal-btn modal-btn-secondary" title="Clear search" style="height:34px;padding:6px 10px;">âœ•</button>
  </div>
</div>

            <!-- Friends List View -->
            <div class="friends-list-view" id="friendsListView">
                <div class="friends-section">
                    <div class="friends-section-title">Direct Messages</div>
                    <div id="dmListContainer"></div>
                </div>

            </div>

            <!-- Channel List View (initially hidden) -->
            <div class="channel-list" id="channelListView" style="display:none;">
                <div class="channel-item" onclick="openChannel('general', event)"><span class="channel-icon">ðŸ’¬</span><span> General</span></div>
                <div class="channel-item" onclick="openChannel('codehsplus', event)"><span class="channel-icon">ðŸŽ®</span><span>CodeHS</span></div>
                <div class="channel-item" onclick="openChannel('media', event)"><span class="channel-icon">ðŸŽ¬</span><span>Media</span></div>
                <div class="channel-item" onclick="openChannel('school', event)"><span class="channel-icon">ðŸ“–</span><span>School</span></div>
            </div>

            <div class="user-profile">
                <div class="user-avatar"></div>
                <div class="user-info">
<!-- make it a little more explicit / accessible -->
<div class="username" id="profileName" data-anonymous="true" role="status" aria-live="polite">Guest</div>

                    <div class="user-id" id="profileId"></div>
                </div>
                <button class="settings-btn" onclick="openSettings()">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M12 15.5A3.5 3.5 0 0 1 8.5 12A3.5 3.5 0 0 1 12 8.5a3.5 3.5 0 0 1 3.5 3.5a3.5 3.5 0 0 1-3.5 3.5m7.43-2.53c.04-.32.07-.64.07-.97c0-.33-.03-.66-.07-1l2.11-1.63c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.31-.61-.22l-2.49 1c-.52-.39-1.06-.73-1.69-.98l-.37-2.65A.506.506 0 0 0 14 2h-4c-.25 0-.46.18-.5.42l-.37 2.65c-.63.25-1.17.59-1.69.98l-2.49-1c-.22-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64L4.57 11c-.04.34-.07.67-.07 1c0 .33.03.65.07.97l-2.11 1.66c-.19.15-.25.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1.01c.52.4 1.06.74 1.69.99l.37 2.65c.04.24.25.42.5.42h4c.25 0 .46-.18.5-.42l.37-2.65c.63-.26 1.17-.59 1.69-.99l2.49 1.01c.22.08.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.66Z"/></svg>
                </button>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <div class="chat-header" id="chatHeader">
                <div class="channel-name">Select a conversation</div>
            </div>
            <div class="chat-area" id="chatArea">
                <div class="no-chat-selected"><div style="padding:18px;">ðŸ‘‹ Choose a friend or channel to start messaging</div></div>
            </div>
        </div>

        <!-- Right Sidebar (Users) -->
        <div id="rightSidebar" class="right-sidebar hidden" aria-hidden="true">
<div class="right-header" style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
  <div style="display:flex;align-items:center;gap:12px;">
    <div style="font-weight:700">Users</div>
    <input id="rightUserSearchInput" type="search" placeholder="Search users" aria-label="Search users" class="right-user-search-input" />
  </div>
  <div>
    <button style="background:none;border:none;color:#b9bbbe;cursor:pointer" onclick="toggleRightSidebar()">Close</button>
  </div>
</div>
            <div class="right-body" id="rightUsersBody">
                <!-- user rows inserted here -->
            </div>
        </div>
    </div>

    <!-- Friend Requests Mini Panel -->
    <div id="friendRequestsPanel" class="friend-requests-panel" aria-hidden="true">
        <h4>Friend Requests</h4>
        <div id="frList">
            <div style="color:#9a9da0">No requests</div>
        </div>
        <div style="margin-top:8px;text-align:right;">
            <button class="modal-btn modal-btn-secondary" onclick="toggleFriendRequests()">Close</button>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content" id="settingsContent">
            <div class="modal-header">User Settings</div>

            <div id="settingsBody">


                <div style="margin-bottom:12px;">
                    <label style="display:block; margin-bottom:8px; color:#b9bbbe;">Password</label>
                    <div class="row">
                        <input id="settingsPassword" type="password" class="modal-input flex-1" />
                        <button id="toggleSettingsPassword" class="modal-btn modal-btn-secondary" style="height:40px;">Show</button>
                    </div>
                </div>


                <div id="settingsMessage" class=""></div>

                <!-- inside the Settings Modal (replace the modal-buttons block) -->
<div class="modal-buttons" style="margin-top:18px;">
    <button class="modal-btn modal-btn-secondary" onclick="closeModal()">Close</button>

    <!-- NEW: explicit Save button so Save and Sign Out are separate actions -->
    <button id="settingsSaveBtn" class="modal-btn modal-btn-primary" style="background:#5865f2;color:white">
      Save
    </button>

    <!-- Sign out / Sign in button -->
    <button id="authActionButton" class="modal-btn modal-btn-primary">Sign Out</button>
</div>

            </div>
        </div>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal">
        <div class="modal-content">
            <div class="modal-header" id="authHeader">Welcome â€” Sign in or Create account</div>

            <div style="margin-bottom:8px;">
                <div style="display:flex; gap:8px; margin-bottom:8px;">
                    <button id="tabSignIn" class="modal-btn modal-btn-secondary">Sign In</button>
                    <button id="tabSignUp" class="modal-btn modal-btn-secondary">Sign Up</button>
                </div>

                <label style="display:block; margin-bottom:8px; color:#b9bbbe;">Username</label>
                <input id="authUsername" type="text" class="modal-input" placeholder="Enter username" />

                <label style="display:block; margin-top:8px; margin-bottom:8px; color:#b9bbbe;">Password</label>
                <div style="display:flex; gap:8px; align-items:center;">
                    <input id="authPassword" type="password" class="modal-input flex-1" placeholder="Enter password" />
                    <button id="authTogglePassword" class="modal-btn modal-btn-secondary">Show</button>
                </div>

                <div id="authError" class="error" style="display:none;"></div>
                <div id="authSuccess" class="success" style="display:none;"></div>

                <div class="modal-buttons">
                    <button class="modal-btn modal-btn-secondary" onclick="location.reload()">Cancel</button>
                    <button id="authPrimaryBtn" class="modal-btn modal-btn-primary">Sign In</button>
                </div>
            </div>
        </div>
    </div>

    <!-- hidden file input for message images -->
    <input type="file" id="messageFile" accept="image/*" style="display:none" />

    <!-- Firebase + App Logic -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
        import {
            getDatabase, ref, get, set, child, push, update, remove,
            onValue, query, limitToLast, serverTimestamp, onDisconnect
        } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";

        const firebaseConfig = {
          apiKey: "AIzaSyDfrDIAvNYXLqYLgJ3GlSXj0MoQdRhDO7Y",
          authDomain: "chatplus-ec9b1.firebaseapp.com",
          databaseURL: "https://chatplus-ec9b1-default-rtdb.firebaseio.com",
          projectId: "chatplus-ec9b1",
          storageBucket: "chatplus-ec9b1.firebasestorage.app",
          messagingSenderId: "1012231798295",
          appId: "1:1012231798295:web:724f432c0e7d92de02a652",
          measurementId: "G-FCJ129MS3W"
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        
        window.database = db;


        /* ----------------- small helpers ----------------- */
        const LOCAL_KEY = 'chat_currentUser_v1';
        const MIN_W=180,MIN_H=120,ACTIVE_MS=15000, MAX_IMG_BYTES = 220 * 1024;
        function b64Encode(str) { return btoa(unescape(encodeURIComponent(str))); }
        function b64Decode(b) { return decodeURIComponent(escape(atob(b))); }
        // function saveLocalUser(obj){ localStorage.setItem(LOCAL_KEY, JSON.stringify(obj)); }
        // function loadLocalUser(){ try { return JSON.parse(localStorage.getItem(LOCAL_KEY) || 'null'); } catch(e){ return null; } }
        function clearLocalUser(){ localStorage.removeItem(LOCAL_KEY); }
        function uidFor(u){ try { return encodeURIComponent(String(u||'')).replace(/\./g,'%2E'); } catch(e){ return String(u||''); } }
        function now(){ return Date.now(); }

        /* emoji helpers (encode as firebase-safe key) */
        function encEmojiKey(emoji){
            try { return encodeURIComponent(emoji).replace(/\./g,'%2E'); } catch(e){ return btoa(String(emoji)).replace(/=/g,''); }
        }
        function decEmojiKey(key){
            try { return decodeURIComponent(key); } catch(e){ try{ return atob(key); }catch(err){ return key; } }
        }

        /* ---------- Auth (simple demo, insecure password handling warning) ---------- */
        let authMode = 'signIn';
        async function usernameExistsCaseInsensitive(username) {
            try{
                const snap = await get(ref(db,'users'));
                const users = snap.exists() ? snap.val() : {};
                const lower = username.toLowerCase();
                for (const key in users) if (key.toLowerCase() === lower) return true;
                return false;
            }catch(e){ console.error(e); return false; }
        }
        async function createUser(username,password){
            const encoded = b64Encode(password);
            await set(ref(db, 'users/' + username), { password: encoded, createdAt: Date.now() });
        }
        async function getUser(username){ const snap = await get(ref(db,'users/' + username)); return snap.exists() ? snap.val() : null; }

        async function attemptSignUp() {
            const username = document.getElementById('authUsername').value.trim();
            const password = document.getElementById('authPassword').value;
            showAuthError('');
            if (!username) return showAuthError('Please enter a username.');
            if (!password || password.length < 4) return showAuthError('Choose a password at least 4 characters.');
            const collision = await usernameExistsCaseInsensitive(username);
            if (collision) return showAuthError('That username already exists (case-insensitive).');
            try { await createUser(username,password); saveLocalUser({ username, password: b64Encode(password) }); updateUIForUser(username); closeAuthModal(); showAuthSuccess('Account created and signed in.'); startPresence(username); } catch(e){ console.error(e); showAuthError('Error creating account.'); }
        }

        async function attemptSignIn() {
            const username = document.getElementById('authUsername').value.trim();
            const password = document.getElementById('authPassword').value;
            showAuthError('');
            if (!username) return showAuthError('Enter your username.');
            if (!password) return showAuthError('Enter your password.');
            try {
                const user = await getUser(username);
                if (!user) return showAuthError('Username not found.');
                if ((user.password||'') !== b64Encode(password)) return showAuthError('Incorrect password.');
                saveLocalUser({ username, password: b64Encode(password) });
                updateUIForUser(username);
                closeAuthModal();
                showAuthSuccess('Signed in.');
                startPresence(username);
            } catch(e){ console.error(e); showAuthError('Sign-in failed.'); }
        }



        
        

        function openAuthModal(mode='signIn'){
            authMode = mode;
            document.getElementById('authModal').style.display='flex';
            document.getElementById('authHeader').textContent = mode==='signIn' ? 'Sign in' : 'Create account';
            document.getElementById('authPrimaryBtn').textContent = mode==='signIn' ? 'Sign In' : 'Create Account';
            showAuthError('');
            showAuthSuccess('');
        }
        function closeAuthModal(){ document.getElementById('authModal').style.display='none'; }
        function showAuthError(msg){ const el=document.getElementById('authError'); if(!msg){ el.style.display='none'; el.textContent=''; } else { el.style.display='block'; el.textContent=msg; } }
        function showAuthSuccess(msg){ const el=document.getElementById('authSuccess'); if(!msg){ el.style.display='none'; el.textContent=''; } else { el.style.display='block'; el.textContent=msg; } }

        document.getElementById('tabSignIn').addEventListener('click', ()=>openAuthModal('signIn'));
        document.getElementById('tabSignUp').addEventListener('click', ()=>openAuthModal('signUp'));
        document.getElementById('authPrimaryBtn').addEventListener('click', async ()=>{ if(authMode==='signIn') await attemptSignIn(); else await attemptSignUp(); });
        document.getElementById('authTogglePassword').addEventListener('click', ()=>{ const pwd=document.getElementById('authPassword'); const btn=document.getElementById('authTogglePassword'); if(pwd.type==='password'){ pwd.type='text'; btn.textContent='Hide'; } else { pwd.type='password'; btn.textContent='Show'; }});
        ['authPassword','authUsername'].forEach(id=>{ document.getElementById(id).addEventListener('keypress', (e)=>{ if(e.key==='Enter') document.getElementById('authPrimaryBtn').click(); }); });

// ---- Non-recursive safe updateUIForUser + minimal signout ----
(function(){
  // If we haven't already captured an original, capture it now.
  // This avoids capturing our own safe wrapper if it was previously assigned.
  if (!window.__orig_updateUIForUser) {
    if (typeof window.updateUIForUser === 'function' && window.updateUIForUser.name !== 'updateUIForUserSafe') {
      window.__orig_updateUIForUser = window.updateUIForUser;
    } else {
      window.__orig_updateUIForUser = null;
    }
  }
  
  // Run this in the client console (or include in your app). Assumes realtime DB helpers: ref, get, set, update, remove
async function changeUsername(oldUsername, newUsername){
  if(!oldUsername || !newUsername) {
    console.error('old and new required');
    return { ok:false, error:'missing-names' };
  }
  oldUsername = String(oldUsername).trim();
  newUsername = String(newUsername).trim();
  if(oldUsername === newUsername) { console.warn('same name'); return { ok:false, error:'same' }; }

  console.group(`changeUsername: ${oldUsername} â†’ ${newUsername}`);
  try {
    // 1) basic checks: new name not present
    const newSnap = await get(ref(db, 'users/' + newUsername));
    if(newSnap && newSnap.exists()){
      console.error('new username exists already');
      return { ok:false, error:'exists' };
    }

    // 2) load old user
    const oldSnap = await get(ref(db, 'users/' + oldUsername));
    if(!oldSnap || !oldSnap.exists()){
      console.error('old user not found');
      return { ok:false, error:'old-not-found' };
    }
    const oldData = oldSnap.val() || {};
    console.log('oldData loaded');

    // 3) create new user node with copied data (preserve avatar/password/any metadata)
    const newData = Object.assign({}, oldData, { username: newUsername });
    // if your user objects rely on exact username inside, set it
    await set(ref(db, 'users/' + newUsername), newData);
    console.log('created users/' + newUsername);

    // 4) move friends: friends/<oldUsername> -> friends/<newUsername> and update other users' friend pointers
    const friendsSnap = await get(ref(db, 'friends/' + oldUsername));
    const friendsObj = friendsSnap && friendsSnap.exists() ? friendsSnap.val() : {};
    const friendNames = Object.keys(friendsObj || {});
    console.log('found friends:', friendNames.length);

    // Set reciprocal links for new user and update other users' friend mapping
    for(const friendName of friendNames){
      try {
        // add friend -> newUsername
        await set(ref(db, `friends/${friendName}/${newUsername}`), true);
        // add newUsername -> friend
        await set(ref(db, `friends/${newUsername}/${friendName}`), true);
        // remove friend -> oldUsername
        await remove(ref(db, `friends/${friendName}/${oldUsername}`));
      } catch(e){ console.warn('friend migration for', friendName, e); }
    }
    // remove old user's friends node
    await remove(ref(db, 'friends/' + oldUsername));
    console.log('migrated friends');

    // 5) move incoming friend requests: friendRequests/<oldUsername> -> friendRequests/<newUsername>
    const incomingSnap = await get(ref(db, 'friendRequests/' + oldUsername));
    if(incomingSnap && incomingSnap.exists()){
      const incoming = incomingSnap.val();
      for(const fromUser of Object.keys(incoming || {})){
        try {
          await set(ref(db, `friendRequests/${newUsername}/${fromUser}`), incoming[fromUser]);
          await remove(ref(db, `friendRequests/${oldUsername}/${fromUser}`));
        } catch(e){ console.warn('incoming friendRequests move', fromUser, e); }
      }
      // remove old node if empty
      try { await remove(ref(db, 'friendRequests/' + oldUsername)); }catch(e){}
    }
    console.log('migrated incoming friend requests');

    // 6) move outgoing friend requests: any friendRequests/<target>/<oldUsername> => friendRequests/<target>/<newUsername>
    // We'll scan root friendRequests node (could be heavy on huge DBs).
    const allRequestsSnap = await get(ref(db, 'friendRequests'));
    if(allRequestsSnap && allRequestsSnap.exists()){
      const allRequests = allRequestsSnap.val();
      for(const targetUser of Object.keys(allRequests || {})){
        try {
          const node = allRequests[targetUser] || {};
          if(node[oldUsername]){
            await set(ref(db, `friendRequests/${targetUser}/${newUsername}`), node[oldUsername]);
            await remove(ref(db, `friendRequests/${targetUser}/${oldUsername}`));
            console.log('moved outgoing request at', targetUser);
          }
        } catch(e){ console.warn('outgoing request migrate for', targetUser, e); }
      }
    }
    console.log('migrated outgoing friend requests');

    // 7) move onlineUsers entry if present (onlineUsers keyed by uidFor(username) in your code)
    try {
      const oldUid = uidFor(oldUsername);
      const newUid = uidFor(newUsername);
      const onlineSnap = await get(ref(db, `onlineUsers/${oldUid}`));
      if(onlineSnap && onlineSnap.exists()){
        const val = onlineSnap.val();
        val.username = newUsername;
        await set(ref(db, `onlineUsers/${newUid}`), val);
        await remove(ref(db, `onlineUsers/${oldUid}`));
        console.log('migrated onlineUsers entry');
      }
    } catch(e){ console.warn('onlineUsers migration failed', e); }

    // 8) MIGRATE DM THREADS AND MESSAGES (chat/messages)
    // Strategy: find dm_... keys that include oldUsername and move them to new thread id(s).
    const messagesRootSnap = await get(ref(db, 'chat/messages'));
    if(messagesRootSnap && messagesRootSnap.exists()){
      const msgsRoot = messagesRootSnap.val();
      const threads = Object.keys(msgsRoot || {});
      for(const threadId of threads){
        if(!threadId.startsWith('dm_')) continue;
        // decode list of participants from threadId (we used encodeURIComponent sorted)
        try {
          // parse participants by stripping 'dm_' and splitting on '_' (encoded)
          const parts = threadId.slice(3).split('_');
          // decode
          const participants = parts.map(p => decodeURIComponent(p));
          if(participants.includes(oldUsername)){
            const other = participants.find(p => p !== oldUsername);
            const newThread = 'dm_' + encodeURIComponent( [newUsername, other].sort()[0] ) + '_' + encodeURIComponent( [newUsername, other].sort()[1] );
            if(newThread === threadId){
              // no change (shouldn't happen) â€” skip
              continue;
            }
            console.log('migrating thread', threadId, 'â†’', newThread);

            // read both nodes
            const oldThreadSnap = await get(ref(db, 'chat/messages/' + threadId));
            const oldMsgs = oldThreadSnap && oldThreadSnap.exists() ? oldThreadSnap.val() : {};
            const newThreadSnap = await get(ref(db, 'chat/messages/' + newThread));
            const newMsgs = newThreadSnap && newThreadSnap.exists() ? newThreadSnap.val() : {};

            // merge: if keys collide, keep newest (by ts) or rekey â€” we will merge by preserving keys and adding missing ones.
            const merged = Object.assign({}, newMsgs); // start with existing
            for(const k of Object.keys(oldMsgs || {})){
              if(!(k in merged)){
                merged[k] = oldMsgs[k];
              } else {
                // collision: keep the one with larger ts
                const aTs = Number(merged[k] && merged[k].ts) || 0;
                const bTs = Number(oldMsgs[k] && oldMsgs[k].ts) || 0;
                if(bTs > aTs) merged[k] = oldMsgs[k];
              }
            }

            // write merged to newThread (replace)
            await set(ref(db, 'chat/messages/' + newThread), merged);
            // remove old thread
            await remove(ref(db, 'chat/messages/' + threadId));

            // also move typing and any other chat nodes for that thread
            try {
              const oldTypingSnap = await get(ref(db, 'chat/typing/' + threadId));
              if(oldTypingSnap && oldTypingSnap.exists()){
                await set(ref(db, 'chat/typing/' + newThread), oldTypingSnap.val());
                await remove(ref(db, 'chat/typing/' + threadId));
              }
            } catch(e){ console.warn('typing migrate', e); }
          }
        } catch(e){
          console.warn('thread parse failed', threadId, e);
        }
      }
    }
    console.log('migrated DM threads (best-effort)');

    // 9) move chat/typing/global entries for user (uid keys)
    try {
      const oldKey = uidFor(oldUsername);
      const newKey = uidFor(newUsername);
      const gTypingSnap = await get(ref(db, 'chat/typing/global/' + oldKey));
      if(gTypingSnap && gTypingSnap.exists()){
        await set(ref(db, 'chat/typing/global/' + newKey), gTypingSnap.val());
        await remove(ref(db, 'chat/typing/global/' + oldKey));
      }
    } catch(e){ console.warn('global typing migrate', e); }

    // 10) Remove old users node (we already created new), but keep a backup under 'users_renamed_backup/<oldUsername>_ts' if you wish
    try {
      // copy backup (optional)
      const backupPath = `users_renamed_backup/${oldUsername}_${Date.now()}`;
      await set(ref(db, backupPath), oldData);
      // remove old node
      await remove(ref(db, 'users/' + oldUsername));
      console.log('created backup and removed users/' + oldUsername);
    } catch(e){ console.warn('cleanup of old user node failed', e); }

    // 11) update last-read/unread local maps in localStorage
    try {
      const READ_MAP_KEY = 'chat_last_read_map_v1';
      const stored = JSON.parse(localStorage.getItem(READ_MAP_KEY) || '{}') || {};
      const newStored = {};
      Object.keys(stored).forEach(k => {
        // replace occurrences of oldUsername in dm key names
        if(k.startsWith('dm_') && k.includes(encodeURIComponent(oldUsername))){
          const parts = k.slice(3).split('_').map(p => decodeURIComponent(p));
          const other = parts.find(p => p !== oldUsername);
          if(other){
            const newKey = 'dm_' + encodeURIComponent([newUsername, other].sort()[0]) + '_' + encodeURIComponent([newUsername, other].sort()[1]);
            newStored[newKey] = stored[k];
            return;
          }
        }
        // otherwise copy as-is
        newStored[k] = stored[k];
      });
      localStorage.setItem(READ_MAP_KEY, JSON.stringify(newStored));
      console.log('updated local last-read map');
    } catch(e){ console.warn('local read map migrate failed', e); }

    // 12) update local storage auth and UI
    try {
      const cur = loadLocalUser && loadLocalUser();
      const newLocal = Object.assign({}, cur || {}, { username: newUsername });
      saveLocalUser && saveLocalUser(newLocal);
      // call UI refresh helpers you have
      try { updateUIForUser && updateUIForUser(newUsername); } catch(e2){ console.warn('updateUIForUser call failed', e2); }
      try { renderUserLists && renderUserLists(); } catch(e3){ console.warn('renderUserLists failed', e3); }
      try { updateAvatarsInUI && updateAvatarsInUI(); } catch(e4){ console.warn('updateAvatarsInUI failed', e4); }
      console.log('local storage and UI updated');
    } catch(e){ console.warn('local update failed', e); }

    console.log('username change finished (best-effort). Please test flows and fix any stray references.');
    console.groupEnd();
    return { ok:true };
  } catch(err){
    console.error('rename failed', err);
    console.groupEnd();
    return { ok:false, error: String(err) };
  }
}


  // Non-recursive safe wrapper. Always call the saved original via window.__orig_updateUIForUser.
  function updateUIForUserSafe(username){
    try {
      // Signed-out minimal cleanup:
      if (!username) {
            setProfileName(null);
          
        // clear profile avatar area
        try {
          const profileAvatar = document.querySelector('.user-avatar');
          if (profileAvatar) {
            setProfileName(username);
            profileAvatar.style.backgroundImage = '';
            profileAvatar.style.background = '#5865f2';
            profileAvatar.textContent = '';
          }
        } catch (e) {}

        // clear obvious username displays
        try {
          document.querySelectorAll('.current-username, .profile-name, .chat-header .channel-name, .channel-name')
            .forEach(el => { try { el.textContent = ''; } catch(e){} });
        } catch(e){}

        // simple chat area reset
        try {
          const chatArea = document.getElementById('chatArea');
          if (chatArea) chatArea.innerHTML = `<div class="no-chat-selected"><div style="padding:18px;">ðŸ‘‹ Choose a friend or channel to start messaging</div></div>`;
        } catch(e){}

        // clear in-memory snapshots (best-effort)
        try { if (typeof friendsSnapshot !== 'undefined') friendsSnapshot = {}; } catch(e){}
        try { if (typeof incomingFriendRequests !== 'undefined') incomingFriendRequests = {}; } catch(e){}
        try { if (typeof outgoingFriendRequests !== 'undefined') outgoingFriendRequests = {}; } catch(e){}

        // re-render minimal lists safely
        try { if (typeof renderUserLists === 'function') renderUserLists(); } catch(e){}
        try { if (typeof renderFriendRequestsUI === 'function') renderFriendRequestsUI(); } catch(e){}
        try { if (typeof recomputeAndRenderBadges === 'function') recomputeAndRenderBadges(); } catch(e){}

        // detach any active thread listeners (best-effort)
        try { if (typeof detachActiveThread === 'function') detachActiveThread(); } catch(e){}

        return;
      }

      // Signed-in path: call original (non-recursively) if we captured it
      const orig = window.__orig_updateUIForUser;
      if (orig && typeof orig === 'function') {
        try {
          orig(username);
          return;
        } catch (err) {
          console.warn('updateUIForUser original threw â€” falling back to minimal update', err);
          // fall through to minimal fallback
        }
      }

      // Fallback minimal signed-in UI update (if original not present or threw)
      try {
        const profileAvatar = document.querySelector('.user-avatar');
        const initial = String(username || '').slice(0,2).toUpperCase();
        const a = (typeof getAvatarFor === 'function') ? getAvatarFor(username) : null;
        if (profileAvatar) {
              setProfileName(username);
          if (a) {
            profileAvatar.style.backgroundImage = `url("${a.replace(/"/g,'\\"')}")`;
            profileAvatar.textContent = '';
          } else {
            profileAvatar.style.backgroundImage = '';
            profileAvatar.style.background = '#5865f2';
            profileAvatar.textContent = initial;
          }
        }
      } catch(e){ /* swallow */ }

    } catch(e){
      console.warn('updateUIForUserSafe failed', e);
    }
  }

  // Replace global function with safe wrapper (idempotent)
  try { window.updateUIForUser = updateUIForUserSafe; } catch(e){ console.warn('failed to set updateUIForUser safe wrapper', e); }

  // Minimal sign-out that clears local client state and uses the safe updater
  function simpleSignOut(){
    try {
      // clear local auth
      try { localStorage.removeItem('LOCAL_KEY'); } catch(e){}
      // clear read map / send ts / session keys
      try { localStorage.removeItem('chat_last_read_map_v1'); } catch(e){}
      try { localStorage.removeItem('chat_last_global_send_ts_v1'); } catch(e){}
      try { sessionStorage.removeItem('t_chat_unlocked_v1'); } catch(e){}
      try { sessionStorage.removeItem('t_chat_bind_v1'); } catch(e){}

      // clear in-memory pointers (best-effort)
      try { if (typeof CURRENT_USER !== 'undefined') CURRENT_USER = null; } catch(e){}
      try { if (typeof pendingAvatarDataUrl !== 'undefined') pendingAvatarDataUrl = null; } catch(e){}
      try { if (typeof myKey !== 'undefined') myKey = null; } catch(e){}
      try { if (typeof myPresenceRef !== 'undefined') myPresenceRef = null; } catch(e){}
      try { if (typeof presenceInterval !== 'undefined') { clearInterval(presenceInterval); presenceInterval = null; } } catch(e){}

      // detach listeners safely
      try { if (typeof detachActiveThread === 'function') detachActiveThread(); } catch(e){}
      try { if (typeof stopChatListeners === 'function') stopChatListeners(); } catch(e){}
      try { if (typeof stopPresenceImmediate === 'function') stopPresenceImmediate(); } catch(e){}

      // update UI with safe wrapper
      try { if (typeof window.updateUIForUser === 'function') window.updateUIForUser(null); } catch(e){ console.warn('updateUIForUserSafe call failed', e); }
        
      // show sign-in modal if available, otherwise reload
      try {
        if (typeof openAuthModal === 'function') openAuthModal('signIn');
        else location.reload();
      } catch(e){
        try { location.reload(); } catch(e){}
      }

      console.log('simpleSignOut: cleared client auth and showed sign-in UI');
    } catch (err) {
      console.error('simpleSignOut failed', err);
      try { location.reload(); } catch(e){}
    }
  }

  // Expose sign out override idempotently
  try { window.simpleSignOut = simpleSignOut; window.signOut = simpleSignOut; } catch(e){}
})();





        /* ----------------- PRESENCE & TYPING (per-thread-aware) ----------------- */
        const ONLINE_ROOT = ref(db, 'onlineUsers');
        const CHAT_ROOT = ref(db, 'chat');
        // typing now uses per-thread nodes, plus a 'global' fallback
        // e.g. chat/typing/<threadId>/<uid>  OR chat/typing/global/<uid>
        let myKey = null, mySession=null, myPresenceRef=null, presenceInterval=null;
        function randomSession(){ return crypto && crypto.randomUUID ? crypto.randomUUID() : 'sess_' + Math.random().toString(36).slice(2,10); }



// add near your other global state variables
let usersSnapshot = {};         // will be kept up-to-date from db/users
function getAvatarFor(username){
  try {
    if(!username) return null;
    const u = usersSnapshot && usersSnapshot[username];
    if(!u) return null;
    // support both .avatar (dataURL) and .avatarUrl (future remote URLs)
    return (typeof u.avatar === 'string' && u.avatar) ? u.avatar : (typeof u.avatarUrl === 'string' ? u.avatarUrl : null);
  } catch(e) { return null; }
}



/* ----------------- Fixed unread counters (per-thread + totals) -----------------
   Paste this after your helper functions/constants and before booting listeners.
   Removes prior unread implementations; this one handles thread ID parsing
   and sets lastRead to the last message timestamp when opening a thread.
------------------------------------------------------------------------- */

const READ_MAP_KEY = 'chat_last_read_map_v1';
let lastReadMap = {};       // { threadId: timestamp }
let unreadCountMap = {};    // { threadId: unreadCount }
let dmTotalUnread = 0;
let serverTotalUnread = 0;

function loadReadMap(){
  try { lastReadMap = JSON.parse(localStorage.getItem(READ_MAP_KEY) || '{}') || {}; } catch(e){ lastReadMap = {}; }
  return lastReadMap;
}
function saveReadMap(){ try { localStorage.setItem(READ_MAP_KEY, JSON.stringify(lastReadMap || {})); } catch(e){} }
function getLastRead(threadId){ loadReadMap(); return Number(lastReadMap[threadId] || 0); }

function setLastRead(threadId, ts){
  if(!threadId) return;
  loadReadMap();
  lastReadMap[threadId] = Number(ts || Date.now());
  saveReadMap();
  // recompute only that thread (fast) and then update badges & totals
  recomputeUnreadForThread(threadId);
}


function _parseMsgTsToNumber(m){
  // Return numeric ms timestamp if present; otherwise return 0.
  try {
    const t = m && m.ts;
    if (typeof t === 'number' && isFinite(t)) return Math.floor(t);
    if (typeof t === 'string' && /^\d+$/.test(t)) return Number(t);
    // Don't treat server-timestamp placeholder objects as "now" â€” treat as unknown => 0
    // (previous behavior of returning Date.now() made everything unread)
    return 0;
  } catch(e){
    return 0;
  }
}



// Replace your existing recomputeUnreadFromMessagesTree function with this version.
function recomputeUnreadFromMessagesTree(tree){
  try {
    // keep a copy of the previous map so we can avoid clearing counts on transient missing data
    const previousMap = Object.assign({}, unreadCountMap || {});

    // defensive: ensure read map is loaded
    loadReadMap();

    // If we don't currently have a usable messages tree, don't overwrite previous counts.
    // Just re-render badges from whatever we already know.
    if(!tree || typeof tree !== 'object'){
      // Recompute aggregates from previousMap (safe) and render
      dmTotalUnread = 0;
      serverTotalUnread = 0;
      Object.keys(previousMap).forEach(tid => {
        const c = previousMap[tid] || 0;
        if(tid.startsWith('dm_')) dmTotalUnread += c;
        else if(tid.startsWith('channel_')) serverTotalUnread += c;
      });
      // ensure unreadCountMap remains at least the previousMap
      unreadCountMap = previousMap;
      recomputeAndRenderBadges();
      return;
    }

    // Build a fresh map from the provided tree (only for threads we can inspect)
    const newMap = {};
    Object.keys(tree).forEach(threadId => {
      const msgsObj = tree[threadId] || {};
      const lastRead = getLastRead(threadId) || 0;
      let unread = 0;

      Object.keys(msgsObj).forEach(msgKey => {
        const m = msgsObj[msgKey] || {};
        // use the centralized parser if available
        const ts = (typeof _parseMsgTsToNumber === 'function') ? _parseMsgTsToNumber(m) : (typeof m.ts === 'number' ? m.ts : Number(m.ts || 0));
        if(ts > lastRead) unread++;
      });

      newMap[threadId] = unread;
    });

    // Merge semantics:
    // - For threads we computed above, use new values.
    // - For threads that existed previously but are missing from `tree` right now,
    //   preserve previous counts (avoids transient badge disappearance).
    Object.keys(previousMap).forEach(tid => {
      if(!(tid in newMap)) newMap[tid] = previousMap[tid];
    });

    // Commit merged map and recompute aggregates
    unreadCountMap = newMap;
    dmTotalUnread = 0;
    serverTotalUnread = 0;
    Object.keys(unreadCountMap).forEach(tid => {
      const c = unreadCountMap[tid] || 0;
      if(tid.startsWith('dm_')) dmTotalUnread += c;
      else if(tid.startsWith('channel_')) serverTotalUnread += c;
    });

    // Debug note (remove if noisy)
    console.debug('Unread recomputed (merged) â€” dmTotal:', dmTotalUnread, 'serverTotal:', serverTotalUnread);

    recomputeAndRenderBadges();
  } catch (e) {
    console.warn('recomputeUnreadFromMessagesTree failed', e);
    // keep whatever we had and re-render to avoid clearing UI
    recomputeAndRenderBadges();
  }
}


// Render nav badges, DM list badges and channel badges
function recomputeAndRenderBadges(){


  // Nav Server badge
  try {
    const navServer = document.getElementById('navServer');
    if(navServer){
      let existing = navServer.querySelector('.nav-unread-badge');
      if(serverTotalUnread > 0){
        if(!existing){
          existing = document.createElement('span');
          existing.className = 'nav-unread-badge unread-badge';
          existing.style.position = 'absolute';
          existing.style.right = '6px';
          existing.style.top = '6px';
          existing.style.minWidth = '20px';
          existing.style.textAlign = 'center';
          existing.style.padding = '2px 6px';
          existing.style.fontSize = '12px';
          existing.style.fontWeight = '700';
          navServer.appendChild(existing);
        }
        existing.textContent = serverTotalUnread > 99 ? '99+' : serverTotalUnread;
      } else {
        if(existing) existing.remove();
      }
    }
  } catch(e){ console.warn('navServer badge update failed', e); }

  // DM friend badges (uses dmListContainer produced by renderUserLists)
  try {
    const dmContainer = document.getElementById('dmListContainer');
    const cur = loadLocalUser();
    const me = cur && cur.username ? cur.username : null;
    if(dmContainer){
      Array.from(dmContainer.children).forEach(child => {
        try{
          const nameEl = child.querySelector('.dm-friend-name');
          const friendName = nameEl ? (nameEl.textContent || '').trim() : null;
          if(!friendName) return;
          const thread = threadIdForDM(me, friendName);
          const cnt = unreadCountMap[thread] || 0;
          let b = child.querySelector('.dm-unread-badge');
          if(cnt > 0){
            if(!b){
              b = document.createElement('div');
              b.className = 'dm-unread-badge unread-badge';
              b.style.marginLeft = '8px';
              b.style.minWidth = '20px';
              b.style.textAlign = 'center';
              b.style.padding = '2px 6px';
              b.style.fontSize = '12px';
              b.style.fontWeight = '700';
              child.appendChild(b);
            }
            b.textContent = cnt > 99 ? '99+' : cnt;
          } else {
            if(b) b.remove();
          }
        }catch(e){ /* per-row safe */ }
      });
    }
  } catch(e){ console.warn('dm friend badges update failed', e); }

  // Channel badges (try to extract channel name from onclick or data-channel-name)
  try {
    const container = document.getElementById('channelListView');
    if(container){
      const items = container.querySelectorAll('.channel-item');
      items.forEach(it => {
        let channelName = it.getAttribute('data-channel-name');
        if(!channelName){
          // try to parse onclick attribute like: openChannel('general', event)
          const onclickTxt = it.getAttribute('onclick') || '';
          const m = onclickTxt.match(/openChannel\(\s*['"]([^'"]+)['"]/);
          if(m && m[1]) channelName = m[1];
          else {
            // fallback: try to strip emoji and whitespace from innerText
            const text = (it.textContent || '').trim();
            // remove leading emoji glyphs and spaces (best-effort)
            channelName = text.replace(/^[^\w#]+/,'').replace(/^#?/,'').trim();
          }
          if(channelName) it.setAttribute('data-channel-name', channelName);
        }
        if(!channelName) return;
        const threadId = threadIdForChannel(channelName);
        const cnt = unreadCountMap[threadId] || 0;
        let badge = it.querySelector('.channel-unread-badge');
        if(cnt > 0){
          if(!badge){
            badge = document.createElement('span');
            badge.className = 'channel-unread-badge unread-badge';
            badge.style.marginLeft = '8px';
            badge.style.fontSize = '12px';
            badge.style.padding = '2px 6px';
            badge.style.borderRadius = '10px';
            it.appendChild(badge);
          }
          badge.textContent = cnt > 99 ? '99+' : cnt;
        } else {
          if(badge) badge.remove();
        }
      });
    }
  } catch(e){ console.warn('channel badges update failed', e); }
}

let messagesTreeCache = null;

/* === update your messagesRoot onValue listener to keep the cache ===
   If you already have an installMessagesTreeListener that uses onValue(ref(db,'chat/messages')...)
   replace its callback body with the following small change (or add the messagesTreeCache update inside it).
*/
(function installMessagesTreeListener(){
  try {
    const messagesRoot = ref(db, 'chat/messages');
    onValue(messagesRoot, snap => {
      // keep an up-to-date in-memory cache of the messages tree
      messagesTreeCache = snap.exists() ? snap.val() : null;
      // recompute unread counts from the cached tree
      recomputeUnreadFromMessagesTree(messagesTreeCache);
    }, err => {
      console.warn('messagesRoot onValue error', err);
    });
  } catch(e){ console.warn('installMessagesTreeListener failed', e); }
})();


async function fetchLastMessageTsForThread(threadId){
  try {
    if(!threadId) return 0;
    const snap = await get(ref(db, 'chat/messages/' + threadId));
    if(!snap || !snap.exists()) return 0;
    const msgs = snap.val();
    let max = 0;
    Object.keys(msgs).forEach(k => {
      const t = _parseMsgTsToNumber(msgs[k] || {});
      if(t > max) max = t;
    });
    return max || 0;
  } catch(e){
    console.warn('fetchLastMessageTsForThread failed', e);
    return 0;
  }
}

// ----------------- Friend request badge helper -----------------
function updateFriendRequestBadge(){
  try {
    const navFR = document.getElementById('navFR');
    const panel = document.getElementById('friendRequestsPanel');
    const count = Object.keys(incomingFriendRequests || {}).length;

    // Nav badge (reuses same class used for navDM/navServer)
    if(navFR){
      let existing = navFR.querySelector('.nav-unread-badge');
      if(count > 0){
        if(!existing){
          existing = document.createElement('span');
          existing.className = 'nav-unread-badge unread-badge';
          existing.style.position = 'absolute';
          existing.style.right = '6px';
          existing.style.top = '6px';
          existing.style.minWidth = '20px';
          existing.style.textAlign = 'center';
          existing.style.padding = '2px 6px';
          existing.style.fontSize = '12px';
          existing.style.fontWeight = '700';
          navFR.appendChild(existing);
        }
        existing.textContent = count > 99 ? '99+' : String(count);
      } else {
        if(existing) existing.remove();
      }
    }

    // Panel header small count bubble (.fr-count)
    if(panel){
      const h4 = panel.querySelector('h4');
      if(h4){
        let span = h4.querySelector('.fr-count');
        if(!span){
          span = document.createElement('span');
          span.className = 'fr-count';
          span.style.marginLeft = '8px';
          span.style.padding = '4px 8px';
          span.style.borderRadius = '999px';
          span.style.background = 'linear-gradient(90deg,#5865f2,#7b8aff)';
          span.style.color = '#fff';
          span.style.fontSize = '12px';
          span.style.fontWeight = '700';
          h4.appendChild(span);
        }
        span.textContent = count > 99 ? '99+' : String(count);
        span.style.display = count > 0 ? '' : 'none';
      }
    }
  } catch(e){
    console.warn('updateFriendRequestBadge failed', e);
  }
}



function recomputeUnreadForThread(threadId){
  try{
    if(!threadId) return;
    if(!messagesTreeCache) {
      // no cache yet -- fallback to re-running full recompute (which will use cache when available)
      recomputeUnreadFromMessagesTree(messagesTreeCache);
      return;
    }
    const msgsObj = messagesTreeCache[threadId] || {};
    const lastRead = getLastRead(threadId) || 0;
    let unread = 0;
    Object.keys(msgsObj).forEach(k=>{
      const m = msgsObj[k] || {};
      const ts = _parseMsgTsToNumber ? _parseMsgTsToNumber(m) : (typeof m.ts === 'number' ? m.ts : Number(m.ts || 0));
      if(ts > lastRead) unread++;
    });
    // update cached maps and aggregates
    const prev = unreadCountMap[threadId] || 0;
    unreadCountMap[threadId] = unread;

    // recompute totals quickly (adjust incrementally)
    // simplest: recompute aggregates from scratch based on unreadCountMap
    dmTotalUnread = 0; serverTotalUnread = 0;
    Object.keys(unreadCountMap).forEach(tid=>{
      const c = unreadCountMap[tid] || 0;
      if(tid.startsWith('dm_')) dmTotalUnread += c;
      else if(tid.startsWith('channel_')) serverTotalUnread += c;
    });

    // now update UI badges
    recomputeAndRenderBadges();
  }catch(e){ console.warn('recomputeUnreadForThread failed', e); }
}



if(typeof openDM === 'function'){
  const _origOpenDM = openDM;
  window.openDM = async function(friendName){
    try { _origOpenDM(friendName); } catch(e){ console.warn('openDM original failed', e); }
    const cur = loadLocalUser();
    if(!cur || !cur.username) return;
    try {
      const thread = threadIdForDM(cur.username, friendName);
      const lastTs = await fetchLastMessageTsForThread(thread);
      // if no messages, use now so new incoming messages count correctly from this point on
      setLastRead(thread, lastTs > 0 ? lastTs : Date.now());
    } catch(err){
      console.warn('openDM lastTs fetch failed', err);
      const thread = threadIdForDM(cur.username, friendName);
      setLastRead(thread, Date.now());
    }
  };
}

if(typeof openChannel === 'function'){
  const _origOpenChannel = openChannel;
  window.openChannel = async function(channelName){
    try { _origOpenChannel(channelName); } catch(e){ console.warn('openChannel original failed', e); }
    try {
      const thread = threadIdForChannel(channelName);
      const lastTs = await fetchLastMessageTsForThread(thread);
      setLastRead(thread, lastTs > 0 ? lastTs : Date.now());
    } catch(err){
      console.warn('openChannel lastTs fetch failed', err);
      const thread = threadIdForChannel(channelName);
      setLastRead(thread, Date.now());
    }
  };
}

// initialize read map
loadReadMap();

// helper to clear cached unread totals (useful on sign out)
function clearAllUnreadCache(){
  lastReadMap = {};
  unreadCountMap = {};
  dmTotalUnread = 0;
  serverTotalUnread = 0;
  try{ localStorage.removeItem(READ_MAP_KEY); }catch(e){}
  recomputeAndRenderBadges();
}



        async function startPresence(username){
            if(!username) return;
            try{
                myKey = uidFor(username);
                mySession = randomSession();
                myPresenceRef = ref(db, 'onlineUsers/' + myKey);
                await set(myPresenceRef, { username, lastActive: serverTimestamp(), session: mySession, meta: 'tetris-client' });
                try{ const od = onDisconnect(myPresenceRef); od.remove(); } catch(e){}
                if(presenceInterval) clearInterval(presenceInterval);
                presenceInterval = setInterval(()=>{ try{ set(myPresenceRef, { username, lastActive: serverTimestamp(), session: mySession, meta: 'tetris-client' }); }catch(e){ console.warn('presence update',e); } }, 5000);
                // attach global lists now that we have identity
                attachGlobalListeners();
            }catch(e){ console.warn('startPresence',e); }
        }

        async function stopPresence(){
            try{
                if(presenceInterval) { clearInterval(presenceInterval); presenceInterval=null; }
                if(myPresenceRef) await remove(myPresenceRef);
            }catch(e){ console.warn('stopPresence',e); } finally { myPresenceRef=null; myKey=null; }
        }

        function stopPresenceImmediate(){
            try{ if(myPresenceRef) remove(myPresenceRef); }catch(e){}
            if(presenceInterval) clearInterval(presenceInterval);
            myPresenceRef=null; myKey=null; presenceInterval=null;
        }

        /* ----------------- Right-hand users panel (open/close) ----------------- */
        function toggleRightSidebar(){
            const el = document.getElementById('rightSidebar');
            el.classList.toggle('hidden');
            el.setAttribute('aria-hidden', el.classList.contains('hidden') ? 'true' : 'false');
        }

        /* ----------------- Friend requests panel toggle ----------------- */
        function toggleFriendRequests(){
            const p = document.getElementById('friendRequestsPanel');
            p.classList.toggle('open');
            p.setAttribute('aria-hidden', !p.classList.contains('open'));
            if(p.classList.contains('open')) renderFriendRequestsUI();
        }

        /* ----------------- Messaging: dynamic threads (channels & DMs) ----------------- */
        // thread naming: channels -> channel_<name> ; dms -> dm_<userA>_<userB> (sorted)
        let activeThreadId = null;
        let activeThreadUnsubscribe = null;
        let typingListenerUnsubscribe = null;
        let typingGlobalUnsubscribe = null;
        let typingSnapshotActiveThread = {};   // typing users in current thread
        let typingGlobalSnapshot = {};         // global typing map (for right users panel)
        let activeThreadMessagesUnsubscribe = null;

        function threadIdForDM(userA, userB){
            const pair = [String(userA), String(userB)].sort();
            return 'dm_' + encodeURIComponent(pair[0]) + '_' + encodeURIComponent(pair[1]);
        }
        function threadIdForChannel(name){ return 'channel_' + name; }

        // detach previous thread listener
        function detachActiveThread(){
            if(typeof activeThreadUnsubscribe === 'function'){ try{ activeThreadUnsubscribe(); }catch(e){} activeThreadUnsubscribe = null; }
            if(typeof typingListenerUnsubscribe === 'function'){ try{ typingListenerUnsubscribe(); }catch(e){} typingListenerUnsubscribe = null; }
            activeThreadId = null;
            typingSnapshotActiveThread = {};
        }

        // attach to messages for thread (full reload on change - simpler, reliable)
        function attachThread(threadId){
            // detach previous thread listeners
            detachActiveThread();
            activeThreadId = threadId;
            const threadRef = ref(db, 'chat/messages/' + threadId);
            // limit to last 250
            const q = query(threadRef, limitToLast(250));
            // messages listener
            activeThreadUnsubscribe = onValue(q, snap => {
                const val = snap.exists() ? snap.val() : {};
                const list = [];
                Object.keys(val).forEach(k => {
                    const v = val[k];
                    list.push({ key: k, username: v.username, text: v.text, ts: v.ts || 0, image: v.image || null, reactions: v.reactions || null });
                });
                
// --- mark-read guard: only when this thread is actually active/visible ---
try {
  // compute newest numeric ts we just received for this thread
  const maxTs = list.reduce((acc, m) => {
    const t = (typeof m.ts === 'number') ? m.ts : Number(m.ts || 0);
    return t > acc ? t : acc;
  }, 0);

  // Only set last-read if this thread is the activeThreadId (i.e. user actually opened it)
  // and the chat area is showing messages (defensive guard)
  if (activeThreadId === threadId) {
    const prevLastRead = getLastRead(threadId) || 0;
    if (maxTs > prevLastRead) {
      setLastRead(threadId, maxTs);
    }
    // NOTE: do NOT auto-set to Date.now() for empty threads here â€” that caused badges to clear.
  }
} catch (err) {
  console.warn('mark-read-on-open (guarded) failed', err);
}
                // sort by ts (serverTimestamp might be number) and render
                list.sort((a,b)=> (a.ts||0) - (b.ts||0));
                renderMessagesForActiveThread(list);
                // wire up favorite stars for any GIFs in the messages
attachMessageGifFavButtons();
attachMessageDeleteButtons();
// existing code that scrolls / sets reactions etc...
// now ensure avatars are applied
try { updateAvatarsInUI(); } catch(e){ console.warn(e); }


            });

            // typing listener for this thread
            const tRef = ref(db, 'chat/typing/' + threadId);
            typingListenerUnsubscribe = onValue(tRef, snap=>{
                typingSnapshotActiveThread = snap.exists() ? snap.val() : {};
                // update UI if the messages view is currently rendered

            });
        }

        function renderReactionsContainer(threadId, msgKey, reactionsObj){
            const container = document.createElement('div');
            container.className = 'reactions';
            if(!reactionsObj) return container;
            const cur = loadLocalUser();
            const myUid = cur && cur.username ? uidFor(cur.username) : null;

            Object.keys(reactionsObj).forEach(enc => {
                const userMap = reactionsObj[enc] || {};
                const emoji = decEmojiKey(enc);
                const count = Object.keys(userMap).filter(k => !!userMap[k]).length;
                if(count <= 0) return;
                const own = myUid && !!userMap[myUid];
                const btn = document.createElement('button');
                btn.className = 'reaction-btn' + (own ? ' own' : '');
                btn.title = `${count} reacted`;
                btn.innerHTML = `<span style="font-size:16px;line-height:1">${emoji}</span><span style="font-size:12px;opacity:.9">${count}</span>`;
                btn.addEventListener('click', ev => { ev.stopPropagation(); toggleReaction(threadId, msgKey, emoji); });
                container.appendChild(btn);
            });
            return container;
        }

        async function toggleReaction(threadId, msgKey, emoji){
            try{
                if(!threadId || !msgKey || !emoji) return;
                const cur = loadLocalUser();
                if(!cur || !cur.username) { openAuthModal('signIn'); return; }
                const userKey = uidFor(cur.username);
                const enc = encEmojiKey(emoji);
                const path = 'chat/messages/' + threadId + '/' + msgKey + '/reactions/' + enc;
                const reactionRef = ref(db, path);
                const snap = await get(reactionRef);
                let current = snap.exists() ? snap.val() : {};
                // toggle
                if(current[userKey]) {
                    delete current[userKey];
                } else {
                    current[userKey] = true;
                }
                // if empty -> remove node, else set updated
                if(Object.keys(current).length === 0){
                    await remove(reactionRef);
                } else {
                    await set(reactionRef, current);
                }
            }catch(e){ console.warn('toggleReaction failed', e); }
        }

        function escapeHtml(s){ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
        
        // safe profile-name updater
function setProfileName(name){
  try {
    const el = document.getElementById('profileName');
    if(!el) return;
    // use existing escapeHtml if available, otherwise fallback
    const esc = (typeof escapeHtml === 'function') ? escapeHtml : (s => String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'));

    if(!name || String(name).trim() === ''){
      el.textContent = 'Guest';
      el.setAttribute('data-anonymous', 'true');
      el.removeAttribute('data-username');
    } else {
      const n = String(name).trim();
      el.textContent = esc(n);
      el.setAttribute('data-username', n);
      el.setAttribute('data-anonymous', 'false');
    }
  } catch(e){
    console.warn('setProfileName failed', e);
  }
}

        
        
        // find http/https URLs in text
function findUrls(text){
  if(!text) return [];
  return String(text).match(/https?:\/\/[^\s]+/g) || [];
}

// heuristic: treat these as image/gif URLs (file extension or known hosts)
function isImageUrl(url){
  if(!url) return false;
  try {
    const u = url.split('?')[0].toLowerCase();
    if(/\.(gif|png|jpg|jpeg|webp|avif)$/i.test(u)) return true;
    // common gif hosts that often serve embeddable gifs
    if(/giphy\.com|tenor\.com|tenor\.app|media\.giphy\.com|i\.imgur\.com/.test(url)) return true;
    return false;
  } catch(e){ return false; }
}


function renderMessagesForActiveThread(list){
    const container = document.getElementById('messagesList');
    if (!container) return;

    const html = [];

    list.forEach(msg => {
        const who = msg.username || 'anon';
        const time = (msg.ts && typeof msg.ts === 'number')
            ? new Date(msg.ts).toLocaleString()
            : 'Just now';

        const avatar = getAvatarFor(who);
        const avatarHtml = avatar
          ? `<div class="message-avatar" style="background-image:url('${avatar}');background-size:cover;background-position:center;margin-right:16px;flex-shrink:0;width:40px;height:40px;border-radius:50%"></div>`
          : `<div class="message-avatar" style="width:40px;height:40px;border-radius:50%;background:${who === (loadLocalUser()?.username) ? '#5865f2' : '#57a55a'};margin-right:16px;flex-shrink:0;"></div>`;

        const imageHtml = msg.image
          ? `<img src="${escapeHtml(msg.image)}" class="message-image" alt="image">`
          : '';

        html.push(`
            <div class="message" data-msgkey="${escapeHtml(msg.key)}" data-ts="${escapeHtml(String(msg.ts || 0))}">
                ${avatarHtml}
                <div class="message-content">
                    <div class="message-header">
                        <span class="message-author">${escapeHtml(who)}</span>
                        <span class="message-time">${escapeHtml(time)}</span>
                    </div>
                    <div class="message-text">${escapeHtml(msg.text||'')}</div>
                    ${imageHtml}
                    <div class="reactions" data-reactions-for="${escapeHtml(msg.key)}"></div>
                    <div style="margin-top:8px;">
                        <button class="modal-btn modal-btn-secondary react-open-btn"
                                data-msg="${escapeHtml(msg.key)}"
                                style="height:28px;padding:6px 10px">
                            React
                        </button>
                    </div>
                </div>
            </div>
        `);
    });

    container.innerHTML = html.join('');
}



    
    
    // mark-read-on-user-action: scroll-to-bottom or focus input
(function attachMarkReadOnUserAction(){
  const messagesEl = document.getElementById('messagesList');
  const inputEl = document.getElementById('activeMessageInput');

  if(!messagesEl) return;

  function lastMessageTsFromDom(){
    const msgs = messagesEl.querySelectorAll('.message[data-ts]');
    if(!msgs || msgs.length === 0) return 0;
    const last = msgs[msgs.length - 1];
    return Number(last.getAttribute('data-ts') || 0) || 0;
  }

  function maybeMarkReadIfAtBottom(){
    try {
      // consider 'near bottom' to accommodate small offsets
      const atBottom = (messagesEl.scrollTop + messagesEl.clientHeight) >= (messagesEl.scrollHeight - 20);
      if(atBottom && activeThreadId){
        const lastTs = lastMessageTsFromDom();
        if(lastTs > 0){
          const prev = getLastRead(activeThreadId) || 0;
          if(lastTs > prev) setLastRead(activeThreadId, lastTs);
        }
      }
    } catch(e){ /* harmless */ }
  }

  // attach listeners (remove existing listeners first to avoid double-binding)
  messagesEl.removeEventListener('scroll', maybeMarkReadIfAtBottom);
  messagesEl.addEventListener('scroll', maybeMarkReadIfAtBottom, { passive: true });

  if(inputEl){
    inputEl.removeEventListener('focus', maybeMarkReadIfAtBottom);
    inputEl.addEventListener('focus', maybeMarkReadIfAtBottom);
  }

  // run once right away in case user opened and UI already scrolled to bottom
  setTimeout(maybeMarkReadIfAtBottom, 50);
})();

    
    
    

    // --- preserve existing post-processing (URL embed etc.) ---
    list.forEach(msg => {
      try {
        const msgKey = msg.key;
        if(!msgKey) return;
        const msgEl = document.querySelector(`.message[data-msgkey="${CSS.escape(msgKey)}"]`);
        if(!msgEl) return;
        const textEl = msgEl.querySelector('.message-text');
        if(!textEl) return;
        const original = msg.text || '';
        const urlRegex = /https?:\/\/[^\s]+/g;
        let match, lastIndex = 0;
        const frag = document.createDocumentFragment();
        let foundAny = false;

        function isImageUrl(url) {
          return /^data:image\/|(\.(jpe?g|png|gif|webp|bmp|svg)(\?|$))/i.test(url);
        }
        function makePlainLink(url) {
          const a = document.createElement('a');
          a.href = url;
          a.target = '_blank';
          a.rel = 'noopener noreferrer';
          a.className = 'message-link message-link-plain';
          a.textContent = url;
          return a;
        }

        while((match = urlRegex.exec(original)) !== null){
          foundAny = true;
          const url = match[0];
          const before = original.slice(lastIndex, match.index);
          if(before) frag.appendChild(document.createTextNode(before));

          if(!/^https?:\/\//i.test(url)){
            frag.appendChild(document.createTextNode(url));
          } else if(isImageUrl(url)){
            const a = document.createElement('a');
            a.href = url;
            a.target = '_blank';
            a.rel = 'noopener noreferrer';
            a.style.display = 'inline-block';
            a.style.textDecoration = 'none';

            const img = document.createElement('img');
            img.src = url;
            img.className = 'message-image message-embed';
            img.alt = url;
            img.referrerPolicy = 'no-referrer';
            img.loading = 'lazy';
            img.style.cursor = 'pointer';
            img.addEventListener('error', () => {
              const fallback = makePlainLink(url);
              a.replaceWith(fallback);
            }, { once: true });

            a.appendChild(img);
            frag.appendChild(a);
          } else {
            frag.appendChild(makePlainLink(url));
          }
          lastIndex = match.index + url.length;
        }

        if(!foundAny) return;
        const tail = original.slice(lastIndex);
        if(tail) frag.appendChild(document.createTextNode(tail));
        textEl.innerHTML = '';
        textEl.appendChild(frag);
      } catch(err){
        console.warn('embed links post-process failed', err);
      }
    });

    // scroll to bottom
    const messagesEl = document.getElementById('messagesList');
    if(messagesEl) messagesEl.scrollTop = messagesEl.scrollHeight;

    // populate reactions area for each message (existing code preserved)
    list.forEach(msg => {
        const holder = document.querySelector(`.reactions[data-reactions-for="${CSS.escape(msg.key)}"]`);
        if(holder){
            holder.innerHTML = '';
            const rc = renderReactionsContainer(activeThreadId, msg.key, msg.reactions || null);
            if(rc && rc.childElementCount) holder.replaceWith(rc);
            else holder.innerHTML = '';
        }
    });

    // react button openers
    document.querySelectorAll('.react-open-btn').forEach(btn => {
        btn.addEventListener('click', (ev) => {
            ev.stopPropagation();
            const key = btn.getAttribute('data-msg');
            openEmojiPickerAt(btn, (emoji) => {
                toggleReaction(activeThreadId, key, emoji);
                closeEmojiPickerPopup();
            });
        });
    });

    // send / input wiring (preserve your handlers)
    const inp = document.getElementById('activeMessageInput');
    const sendBtn = document.getElementById('sendMessageBtn');
    const attachBtn = document.getElementById('attachImageBtn');
    const gifBtn = document.getElementById('attachGifBtn');
    const emojiInsertBtnNow = document.getElementById('emojiInsertBtn');

    if(inp){
        inp.addEventListener('input', onMessageInput);
        inp.addEventListener('keydown', onMessageKeydown);
        if (window.innerWidth > 768) {
            try { inp.focus(); const len = inp.value ? inp.value.length : 0; inp.setSelectionRange(len, len); } catch(e){}
        }
    }
    if(sendBtn){
        sendBtn.addEventListener('click', ()=> {
            const v = inp.value.trim();
            if(v) sendMessageToActiveThread(v, null);
        });
    }

    // attach image
    attachBtn?.addEventListener('click', ()=>{
        document.getElementById('messageFile').click();
    });

    // attach gif picker
    gifBtn?.addEventListener('click', (ev) => {
        ev.stopPropagation();
        openGifPickerAt(gifBtn);
    });

    // emoji insertion into input
    emojiInsertBtnNow?.addEventListener('click', (ev) => {
        openEmojiPickerAt(emojiInsertBtnNow, (emoji) => {
            insertEmojiAtInput(inp, emoji);
            closeEmojiPickerPopup();
        });
    });

    // ensure scroll at bottom
    const mEl = document.getElementById('messagesList');
    if(mEl) mEl.scrollTop = mEl.scrollHeight;
}


// ---------------- GIF / Tenor integration & favorites ----------------

// Replace with your own Tenor API key if you have it. The example key below is often used for demos.
// If you have a private key, replace the string below.
const TENOR_API_KEY = 'LIVDSRZULELA'; // <--- optional: replace this with your key

const GIF_FAVS_KEY = 'chat_gif_favorites_v1';

// utility: safe get gif url from tenor item
function getGifUrlFromTenorItem(item){
    try{
        // Tenor v1 has item.media[0].gif.url or .mediumgif.url or media_formats
        if(item.media && item.media[0]){
            const m = item.media[0];
            if(m.gif && m.gif.url) return m.gif.url;
            if(m.tinygif && m.tinygif.url) return m.tinygif.url;
            if(m.mediumgif && m.mediumgif.url) return m.mediumgif.url;
            // fallback: any key that ends with 'gif':
            for(const k in m){
                if(m[k] && m[k].url && k.toLowerCase().includes('gif')) return m[k].url;
            }
        }
        // fallback to item.url
        if(item.url) return item.url;
    }catch(e){}
    return null;
}

function loadGifFavorites(){
    try{
        return JSON.parse(localStorage.getItem(GIF_FAVS_KEY) || '[]');
    }catch(e){ return []; }
}
function saveGifFavorites(arr){
    try{ localStorage.setItem(GIF_FAVS_KEY, JSON.stringify(arr || [])); }catch(e){}
}
function isGifFavorited(id){
    const favs = loadGifFavorites();
    return favs.some(f=>f.id === id);
}

function toggleGifFavoriteObject(gifObj){
    // gifObj should have { id, url, preview } minimal
    const favs = loadGifFavorites();
    const idx = favs.findIndex(f => f.id === gifObj.id);
    if(idx >= 0){
        favs.splice(idx,1);
        saveGifFavorites(favs);
        return false;
    } else {
        favs.unshift(gifObj);
        // cap favorites to reasonable number
        if(favs.length > 60) favs.length = 60;
        saveGifFavorites(favs);
        return true;
    }
}

// ---------------- Add favorite star to message GIFs ----------------

// Detect likely animated/hosted GIF URLs (used to decide which images get a star)
function isAnimatedImageUrl(url) {
  if(!url) return false;
  try {
    const u = String(url).split('?')[0].toLowerCase();
    // common animated extensions or hosts
    if(/\.(gif|gifv|webp|mp4|m4v)$/i.test(u)) return true;
    if(/giphy\.com|media\.giphy\.com|tenor\.com|tenor\.app|media\.tenor|i\.imgur\.com|imgur\.com|cdn\.instagram|media0\.tenor\.com/.test(u)) return true;
    // sometimes URLs contain 'gif' in path or query
    if(u.includes('gif')) return true;
  } catch(e){}
  return false;
}

// utility: check if a URL is already saved as a favorite (supports id or url matches)
function isUrlFavorited(url){
  const favs = loadGifFavorites(); // uses your existing localStorage helper
  if(!favs || !favs.length) return false;
  return favs.some(f => (f.id && f.id === url) || (f.url && f.url === url) || (f.preview && f.preview === url));
}

// attach star overlays to message images (idempotent)
function attachMessageGifFavButtons(){
  try {
    const imgs = Array.from(document.querySelectorAll('.message-image'));
    imgs.forEach(img => {
      // avoid re-attaching
      if(img.dataset.favAttached) return;
      const src = img.src || img.getAttribute('src') || '';
      if(!isAnimatedImageUrl(src)) return; // only add for animated/gif-like images

      // mark attached
      img.dataset.favAttached = '1';

      // wrap in relative container (if not already wrapped)
      let wrapper = img.closest('.message-img-wrapper');
      if(!wrapper){
        wrapper = document.createElement('div');
        wrapper.className = 'message-img-wrapper';
        // preserve original styles / parent position
        const parent = img.parentNode;
        parent.replaceChild(wrapper, img);
        wrapper.appendChild(img);
      }

      // create star
      const star = document.createElement('div');
      star.className = 'message-gif-fav-star' + (isUrlFavorited(src) ? ' favorited' : '');
      star.innerHTML = isUrlFavorited(src) ? 'â˜…' : 'â˜†';
      star.title = isUrlFavorited(src) ? 'Unfavorite GIF' : 'Favorite GIF';

      // click toggles favorite only â€” important: stopPropagation to avoid any image click behavior
      star.addEventListener('click', (ev) => {
        ev.stopPropagation();
        ev.preventDefault();
        // use same format used by your earlier toggleGifFavoriteObject â€” pass minimal obj
        const gifObj = { id: src, url: src, preview: src };
        const became = toggleGifFavoriteObject(gifObj);
        star.classList.toggle('favorited', became);
        star.innerHTML = became ? 'â˜…' : 'â˜†';
        star.title = became ? 'Unfavorite GIF' : 'Favorite GIF';
        // update pickers/submenus if open
        if(typeof renderGifFavoritesStrip === 'function' && gifPickerPopup) renderGifFavoritesStrip();
        if(typeof renderFavsSubmenuList === 'function' && favsSubmenuEl) renderFavsSubmenuList();
      }, { capture: false });

      // ensure the star doesn't trigger any parent click handlers
      star.addEventListener('pointerdown', (ev) => { ev.stopPropagation(); }, { capture: true });

      // append star to wrapper
      wrapper.appendChild(star);
    });
  } catch(err){
    console.warn('attachMessageGifFavButtons failed', err);
  }
}



// helper: fetch Tenor
async function fetchTenor(q = '', limit = 24){
    const endpoint = q && q.trim().length ? 'search' : 'trending';
    const url = `https://g.tenor.com/v1/${endpoint}?key=${encodeURIComponent(TENOR_API_KEY)}&limit=${limit}&media_filter=minimal&q=${encodeURIComponent(q)}`;
    try{
        const res = await fetch(url);
        if(!res.ok) throw new Error('Tenor fetch failed: ' + res.status);
        const data = await res.json();
        return data && data.results ? data.results : [];
    }catch(e){
        console.warn('fetchTenor error', e);
        return [];
    }
}

// create & manage GIF picker popup
let gifPickerPopup = null;
let gifPickerState = { query: '', page: 0, results: [] };

async function openGifPickerAt(anchorEl){
    closeGifPicker();
    gifPickerPopup = document.createElement('div');
    gifPickerPopup.className = 'gif-picker-popup';
    gifPickerPopup.innerHTML = `
      <div class="gif-picker-top">
         <div class="gif-favs-strip" id="gifFavsStrip" title="Favorites (scroll)"></div>
         <div class="gif-search" style="min-width:220px;">
           <input id="gifSearchInput" placeholder="Search GIFs (Tenor)" />
           <button id="gifSearchBtn" class="modal-btn modal-btn-primary" style="height:36px;">Search</button>
         </div>
         <div class="gif-tabs" style="margin-left:8px">
           <button id="gifTrendingBtn" class="modal-btn modal-btn-secondary" style="height:36px;">Trending</button>
         </div>
      </div>
      <div class="gif-grid" id="gifGrid"></div>
      <div style="display:flex;gap:8px;justify-content:flex-end;">
        <button id="gifCloseBtn" class="modal-btn modal-btn-secondary">Close</button>
      </div>
    `;
    document.body.appendChild(gifPickerPopup);

    // position in center-ish of screen
    const rect = anchorEl.getBoundingClientRect();
    const top = Math.min(window.innerHeight - gifPickerPopup.offsetHeight - 16, Math.max(16, rect.bottom + 8));
    gifPickerPopup.style.left = Math.round((window.innerWidth - gifPickerPopup.offsetWidth) / 2) + 'px';
    gifPickerPopup.style.top = Math.round(Math.max(16, (window.innerHeight - gifPickerPopup.offsetHeight)/2)) + 'px';

    // wire events
    document.getElementById('gifSearchBtn').addEventListener('click', async ()=>{
        const q = document.getElementById('gifSearchInput').value.trim();
        gifPickerState.query = q;
        await loadGifResults(q);
    });
    document.getElementById('gifSearchInput').addEventListener('keydown', async (e)=>{
        if(e.key === 'Enter'){ gifPickerState.query = e.target.value.trim(); await loadGifResults(gifPickerState.query); }
    });
    document.getElementById('gifTrendingBtn').addEventListener('click', async ()=>{
        document.getElementById('gifSearchInput').value = '';
        gifPickerState.query = '';
        await loadGifResults('');
    });
    document.getElementById('gifCloseBtn').addEventListener('click', ()=> closeGifPicker());

    // populate favorites strip & initial results
    renderGifFavoritesStrip();
    await loadGifResults('');
    // handle outside clicks & Escape
    function onDocClick(ev){ if(!gifPickerPopup) return; if(ev.target && gifPickerPopup.contains(ev.target)) return; closeGifPicker(); document.removeEventListener('pointerdown', onDocClick, true); document.removeEventListener('keydown', onEsc, true); }
    function onEsc(ev){ if(ev.key === 'Escape'){ closeGifPicker(); document.removeEventListener('pointerdown', onDocClick, true); document.removeEventListener('keydown', onEsc, true); } }
    document.addEventListener('pointerdown', onDocClick, true);
    document.addEventListener('keydown', onEsc, true);
}

function closeGifPicker(){
    try{ if(gifPickerPopup){ gifPickerPopup.remove(); gifPickerPopup = null; } }catch(e){}
}

// render favorites strip at top of picker
function renderGifFavoritesStrip(){
    if(!gifPickerPopup) return;
    const el = gifPickerPopup.querySelector('#gifFavsStrip');
    if(!el) return;
    el.innerHTML = '';
    const favs = loadGifFavorites();
    if(!favs.length){
        el.innerHTML = `<div class="gif-picker-empty">No favorites â€” click the star on any GIF to add</div>`;
        return;
    }
    favs.forEach(f=>{
        const thumb = document.createElement('div');
        thumb.className = 'gif-fav-thumb';
        thumb.title = 'Click to send GIF';
        const img = document.createElement('img');
        img.src = f.preview || f.url;
        img.alt = 'fav';
        thumb.appendChild(img);
        thumb.addEventListener('click', (ev)=>{
            ev.stopPropagation();
            // send fav gif
            sendMessageToActiveThread('', f.url);
            closeGifPicker();
        });
        // small unfav control overlay
        const star = document.createElement('div');
        star.className = 'gif-fav-star favorited';
        star.innerHTML = 'â˜…';
        star.title = 'Unfavorite';
        star.addEventListener('click', (ev)=>{
            ev.stopPropagation();
            toggleGifFavoriteObject({ id: f.id, url: f.url, preview: f.preview });
            renderGifFavoritesStrip();
            // also refresh grid star states
            updateGifGridFavoriteStates();
        });
        thumb.appendChild(star);
        el.appendChild(thumb);
    });
}

// load and show gif results
async function loadGifResults(query){
    if(!gifPickerPopup) return;
    const grid = gifPickerPopup.querySelector('#gifGrid');
    if(!grid) return;
    grid.innerHTML = '<div style="padding:18px;color:#9a9da0">Loadingâ€¦</div>';
    const results = await fetchTenor(query, 30);
    gifPickerState.results = results;
    if(!results || !results.length){
        grid.innerHTML = '<div class="gif-picker-empty">No results</div>';
        return;
    }
    // build grid
    grid.innerHTML = '';
    results.forEach(item=>{
        const gid = item.id || (item.uuid || item.result_id || (item.url && item.url.split('/').pop()));
        const url = getGifUrlFromTenorItem(item) || item.url || '';
        const preview = (item.media && item.media[0] && (item.media[0].tinygif && item.media[0].tinygif.url)) || url;
        const thumb = document.createElement('div');
        thumb.className = 'gif-thumb';
        thumb.title = (item.title || '').slice(0,80);

        // image
        const img = document.createElement('img');
        img.src = preview;
        img.alt = item.title || 'gif';
        img.loading = 'lazy';
        thumb.appendChild(img);

        // star on top-right
        const star = document.createElement('div');
        star.className = 'gif-fav-star' + (isGifFavorited(gid) ? ' favorited' : '');
        star.innerHTML = isGifFavorited(gid) ? 'â˜…' : 'â˜†';
        star.title = isGifFavorited(gid) ? 'Unfavorite' : 'Favorite';
        star.addEventListener('click', (ev)=>{
            ev.stopPropagation(); // IMPORTANT: do not let this click bubble and trigger sending GIF
            const favObj = { id: gid, url, preview };
            const became = toggleGifFavoriteObject(favObj);
            star.classList.toggle('favorited', became);
            star.innerHTML = became ? 'â˜…' : 'â˜†';
            star.title = became ? 'Unfavorited' : 'Favorite';
            renderGifFavoritesStrip();
        }, { capture: false });

        thumb.appendChild(star);

        // clicking the gif thumb will send the gif (or insert if you prefer)
        thumb.addEventListener('click', (ev)=>{
            ev.stopPropagation();
            // Send GIF as the message image (empty text)
            if(!url){
                alert('Unable to get GIF URL for this item.');
                return;
            }
            sendMessageToActiveThread('', url);
            closeGifPicker();
        });

        grid.appendChild(thumb);
    });
    updateGifGridFavoriteStates();
}

// refresh star states for grid (useful after fav change)
function updateGifGridFavoriteStates(){
    if(!gifPickerPopup) return;
    const stars = gifPickerPopup.querySelectorAll('.gif-thumb .gif-fav-star');
    stars.forEach(s=>{
        const parent = s.closest('.gif-thumb');
        if(!parent) return;
        // attempt to derive id from nearby node; we stored ids only in render step, so rely on preview src or adjacent media
        // best-effort: if the star has been updated in render step, leave as-is
    });
}




        /* --- image handling --- */
        function imageFileToDataURL(file, maxWidth=800, quality=0.72){
            return new Promise((resolve,reject)=>{
                try{
                    const r=new FileReader();
                    r.onerror = e => reject(e);
                    r.onload = ()=>{
                      const img=new Image();
                      img.onerror = e => reject(e);
                      img.onload = ()=>{
                        const scale = Math.min(1, maxWidth / img.width);
                        const w = Math.round(img.width * scale), h = Math.round(img.height * scale);
                        const c=document.createElement('canvas'); c.width=w; c.height=h; const ctx=c.getContext('2d'); ctx.drawImage(img,0,0,w,h);
                        function hasAlpha(){
                          try{
                            const total=w*h, max=1000, step=Math.max(1,Math.floor(Math.sqrt(total/max)));
                            const data=ctx.getImageData(0,0,w,h).data;
                            for(let y=0;y<h;y+=step) for(let x=0;x<w;x+=step){ const idx=(y*w+x)*4; if(data[idx+3]!==255) return true; }
                            return false;
                          }catch(err){ return file && file.type==='image/png'; }
                        }
                        const needsAlpha = hasAlpha();
                        resolve(needsAlpha?c.toDataURL('image/png'):c.toDataURL('image/jpeg',quality));
                      };
                      img.src = r.result;
                    };
                    r.readAsDataURL(file);
                }catch(e){ reject(e); }
            });
        }

        // file input handling
        document.getElementById('messageFile').addEventListener('change', async ev=>{
            const f = ev.target.files && ev.target.files[0];
            if(!f) return;
            const inp = document.getElementById('activeMessageInput');
            // ensure signed in
            const cur = loadLocalUser();
            if(!cur || !cur.username){ openAuthModal('signIn'); document.getElementById('messageFile').value = ''; return; }
            if(!f.type.startsWith('image/')){ alert('Only images allowed'); document.getElementById('messageFile').value = ''; return; }
            try{
                let dataURL = await imageFileToDataURL(f,800,0.72);
                let bytes = Math.round((dataURL.length*3)/4);
                if(bytes > MAX_IMG_BYTES){
                    // try smaller
                    const smaller = await imageFileToDataURL(f,600,0.6);
                    const b2 = Math.round((smaller.length*3)/4);
                    if(b2 > MAX_IMG_BYTES){
                        if(!confirm('Image is still large and may fail to store. Continue?')) { document.getElementById('messageFile').value=''; return; }
                    }
                    await sendMessageToActiveThread(inp ? inp.value : '', smaller);
                } else {
                    await sendMessageToActiveThread(inp ? inp.value : '', dataURL);
                }
            }catch(e){ console.warn('image processing failed', e); alert('Image processing failed. Try a smaller image.'); }
            finally{ document.getElementById('messageFile').value=''; }
        });

        /* typing indicator wiring (re-uses earlier logic) */
        let typingTimer = null;
        function setTyping(state){
            try{
                const cur = loadLocalUser();
                if(!cur || !cur.username) return;
                const key = uidFor(cur.username);
                if(!key) return;
                const threadKey = activeThreadId || 'global';
                const TR = ref(db, 'chat/typing/' + threadKey + '/' + key);
                if(state){
                    set(TR, true);
                    if(typingTimer) clearTimeout(typingTimer);
                    typingTimer = setTimeout(()=>{ set(TR, false).catch(()=>{}); typingTimer=null; },2000);
                } else {
                    set(TR, false).catch(()=>{});
                    if(typingTimer){ clearTimeout(typingTimer); typingTimer=null; }
                }
            }catch(e){ console.warn('setTyping',e); }
        }
        function onMessageInput(){
            setTyping(true);
        }
        function onMessageKeydown(e){
            if(e.key === 'Enter' && !e.shiftKey){
                e.preventDefault();
                const v = e.target.value.trim();
                if(v) sendMessageToActiveThread(v, null);
            }
        }

        /* insert emoji into input caret */
        function insertEmojiAtInput(inputEl, emoji){
            try{
                if(!inputEl) return;
                const start = typeof inputEl.selectionStart === 'number' ? inputEl.selectionStart : inputEl.value.length;
                const end = typeof inputEl.selectionEnd === 'number' ? inputEl.selectionEnd : start;
                const val = inputEl.value || '';
                inputEl.value = val.slice(0,start) + emoji + val.slice(end);
                const caret = start + emoji.length;
                inputEl.selectionStart = inputEl.selectionEnd = caret;
                inputEl.focus();
                inputEl.dispatchEvent(new Event('input',{bubbles:true}));
            }catch(e){ console.warn('insertEmojiAtInput', e); }
        }

        /* emoji picker popup (very small) */
        let emojiPickerPopup = null;
const EMOJI_SET = ['ðŸ˜€','ðŸ˜','ðŸ˜‚','ðŸ¤£','ðŸ™‚','ðŸ˜‰','ðŸ˜','ðŸ˜˜','ðŸ˜Ž','ðŸ¤”','ðŸ˜…','ðŸ˜­','ðŸ˜¡','ðŸ¤¯','ðŸ¤©','ðŸ¤','ðŸ‘','ðŸ‘Ž','ðŸ‘','ðŸ™Œ','ðŸ™','ðŸ¤ž','ðŸ’ª','ðŸŽ‰','â¤ï¸','ðŸ”¥','âœ¨','ðŸ˜®â€ðŸ’¨','ðŸ˜”','ðŸ˜¤','ðŸ˜‘','ðŸ³ï¸â€ðŸŒˆ','ðŸ¥¹','ðŸ¥º','ðŸ¤·â€â™‚ï¸','ðŸ’”','ðŸ¤‘','ðŸ¥€','ðŸ¤“','ðŸ¤¨','âŒ','âœ…','â˜ ï¸','ðŸ§¢','ðŸ˜±'];        function openEmojiPickerAt(anchorEl, onPick){
            closeEmojiPickerPopup();
            emojiPickerPopup = document.createElement('div');
            emojiPickerPopup.className = 'emoji-picker-popup';
            EMOJI_SET.forEach(emo=>{
                const c = document.createElement('div'); c.className='emoji-cell'; c.textContent = emo;
                c.addEventListener('click', (ev)=>{ ev.stopPropagation(); try{ if(typeof onPick === 'function') onPick(emo); }catch(e){ console.warn(e); } closeEmojiPickerPopup(); });
                emojiPickerPopup.appendChild(c);
            });
            document.body.appendChild(emojiPickerPopup);
            // position
            const rect = anchorEl.getBoundingClientRect();
            const topBelow = rect.bottom + 8;
            let top = topBelow;
            if(top + emojiPickerPopup.offsetHeight > window.innerHeight - 8){ top = Math.max(8, rect.top - emojiPickerPopup.offsetHeight - 8); }
            let left = rect.left;
            if(left + emojiPickerPopup.offsetWidth > window.innerWidth - 8){ left = window.innerWidth - emojiPickerPopup.offsetWidth - 8; }
            emojiPickerPopup.style.left = Math.round(left) + 'px';
            emojiPickerPopup.style.top = Math.round(top) + 'px';

            function onDocClick(ev){ if(!emojiPickerPopup) return; if(ev.target && emojiPickerPopup.contains(ev.target)) return; closeEmojiPickerPopup(); document.removeEventListener('pointerdown', onDocClick, true); document.removeEventListener('keydown', onEsc, true); }
            function onEsc(ev){ if(ev.key === 'Escape'){ closeEmojiPickerPopup(); document.removeEventListener('pointerdown', onDocClick, true); document.removeEventListener('keydown', onEsc, true); } }
            document.addEventListener('pointerdown', onDocClick, true);
            document.addEventListener('keydown', onEsc, true);
        }
        function closeEmojiPickerPopup(){ try{ if(emojiPickerPopup){ emojiPickerPopup.remove(); emojiPickerPopup=null; } }catch(e){} }
        window.addEventListener('resize', ()=>closeEmojiPickerPopup());

        /* ----------------- Users & presence list rendering ----------------- */
        // maintain user lists from DB
        let onlineUsersSnapshot = {};
        // friend & friend-requests state
        let friendsSnapshot = {};               // { friendUsername: true, ... } for current user
        let incomingFriendRequests = {};        // { fromUsername: timestamp, ... } incoming to current user

        // new: map of all friendRequests in DB (structure: friendRequests[toUser][fromUser] = ts)
        let globalFriendRequests = {};

        // local map of outgoing requests we've just sent (optimistic UI)
        let outgoingFriendRequests = {};        // { toUsername: true }

        function attachGlobalListeners(){
            // online users list
            onValue(ref(db,'onlineUsers'), snap => {
                const val = snap.exists() ? snap.val() : {};
                onlineUsersSnapshot = val;
                renderUserLists();
            });
            
                        // all friendRequests (root) so we can determine outgoing/pending requests quickly
            onValue(ref(db, 'friendRequests'), snap => {
                globalFriendRequests = snap.exists() ? snap.val() : {};
                // re-render both user lists and friend-requests panel when this changes
                renderUserLists();
                renderFriendRequestsUI();
            });


            // global typing map (used for right-users panel)
            const globalTypingRef = ref(db, 'chat/typing/global');
            if(typeof typingGlobalUnsubscribe === 'function'){ try{ typingGlobalUnsubscribe(); }catch(e){} typingGlobalUnsubscribe = null; }
            typingGlobalUnsubscribe = onValue(globalTypingRef, snap => {
                typingGlobalSnapshot = snap.exists() ? snap.val() : {};
                renderUserLists();
            });
            
            function updateAvatarsInUI(){
  try {
    // profile avatar (top-left)
    const cur = loadLocalUser();
    const me = cur?.username || null;
    const profileAvatarEl = document.querySelector('.user-avatar');
    if(profileAvatarEl && me){
      const a = getAvatarFor(me);
      if(a){
        profileAvatarEl.style.backgroundImage = `url("${a.replace(/"/g,'\\"')}")`;
        profileAvatarEl.style.backgroundSize = 'cover';
        profileAvatarEl.style.backgroundPosition = 'center';
        profileAvatarEl.textContent = '';
      } else {
        profileAvatarEl.style.backgroundImage = '';
        profileAvatarEl.style.background = '#5865f2';
        profileAvatarEl.textContent = me.slice(0,2).toUpperCase();
      }
    }

    // DM list avatars (.dm-friend-avatar)
    document.querySelectorAll('.dm-friend-item').forEach(row => {
      try {
        const uname = row.dataset.username || row.querySelector('.dm-friend-name')?.textContent?.trim();
        const avatarDiv = row.querySelector('.dm-friend-avatar');
        if(!avatarDiv || !uname) return;
        const av = getAvatarFor(uname);
        if(av){
          avatarDiv.style.backgroundImage = `url("${av.replace(/"/g,'\\"')}")`;
          avatarDiv.style.backgroundSize = 'cover';
          avatarDiv.style.backgroundPosition = 'center';
          avatarDiv.textContent = '';
        } else {
          avatarDiv.style.backgroundImage = '';
          avatarDiv.style.background = '#5865f2';
          avatarDiv.textContent = (uname||'').slice(0,2).toUpperCase();
        }
      } catch(e){}
    });

    // message avatars (.message) - find the author and set avatar for its .message-avatar
    document.querySelectorAll('.message').forEach(msgEl => {
      try {
        const author = msgEl.querySelector('.message-author')?.textContent?.trim();
        const avatarEl = msgEl.querySelector('.message-avatar');
        if(!avatarEl || !author) return;
        const av = getAvatarFor(author);
        if(av){
          avatarEl.style.backgroundImage = `url("${av.replace(/"/g,'\\"')}")`;
          avatarEl.style.backgroundSize = 'cover';
          avatarEl.style.backgroundPosition = 'center';
          avatarEl.textContent = '';
        } else {
          avatarEl.style.backgroundImage = '';
          // use same color logic you already had
          const meNow = loadLocalUser()?.username;
          avatarEl.style.background = (author === meNow) ? '#5865f2' : '#57a55a';
        }
      } catch(e){}
    });

    // chat header small avatar (openDM)
    const chatHeaderAvatar = document.querySelector('#chatHeader .message-avatar, #chatHeader .dm-avatar');
    if(chatHeaderAvatar){
      // derive the name shown in header
      const nameEl = document.querySelector('#chatHeader .channel-name');
      const name = nameEl ? nameEl.textContent.replace(/^#/, '').trim() : null;
      if(name){
        const av = getAvatarFor(name);
        if(av){
          chatHeaderAvatar.style.backgroundImage = `url("${av.replace(/"/g,'\\"')}")`;
          chatHeaderAvatar.style.backgroundSize = 'cover';
          chatHeaderAvatar.style.backgroundPosition = 'center';
        } else {
          chatHeaderAvatar.style.backgroundImage = '';
          chatHeaderAvatar.style.background = '#5865f2';
        }
      }
    }
  } catch(e){
    console.warn('updateAvatarsInUI failed', e);
  }
  
}

        window.updateAvatarsInUI = updateAvatarsInUI;


// keep usersSnapshot global (already described earlier)
onValue(ref(db,'users'), snap => {
  try {
    usersSnapshot = snap.exists() ? snap.val() : {};
  } catch(e) {
    usersSnapshot = {};
    console.warn('users onValue parse failed', e);
  }
  // re-render lists so avatars show up in sidebar
  try { renderUserLists(); } catch(e) { /* ignore */ }

  // refresh profile avatar in header (if signed-in)
  try { updateUIForUser(loadLocalUser()?.username); } catch(e){}

  // update avatars in currently rendered messages / chat header
  try { updateAvatarsInUI(); } catch(e){}
});


            // friends & incoming requests for the current (signed-in) user
            const cur = loadLocalUser();
            if(cur && cur.username){
                const friendsRef = ref(db, 'friends/' + cur.username);
                onValue(friendsRef, snap=>{
                    friendsSnapshot = snap.exists() ? snap.val() : {};
                    renderUserLists();
                    get(ref(db,'users')).then(s => renderAllUsers(s.exists()?s.val():{})).catch(()=>{});
                });

                const incomingRef = ref(db, 'friendRequests/' + cur.username);
                onValue(incomingRef, snap=>{
                    incomingFriendRequests = snap.exists() ? snap.val() : {};
                    renderUserLists();
                });
            }
        }

        async function sendFriendRequest(toUsername){
            const cur = loadLocalUser();
            if(!cur || !cur.username) { openAuthModal('signIn'); return; }
            if(toUsername === cur.username) return;

            // optimistic UI
            outgoingFriendRequests[toUsername] = true;
            renderUserLists();

            try{
                await set(ref(db, 'friendRequests/' + toUsername + '/' + cur.username), serverTimestamp());
                console.log('friend request sent to', toUsername);
                // the DB listener on friendRequests will update globalFriendRequests shortly
            }catch(e){
                console.error('sendFriendRequest', e);
                delete outgoingFriendRequests[toUsername];
                renderUserLists();
                alert('Failed to send friend request');
            }
        }
        
        async function cancelFriendRequest(toUsername){
            const cur = loadLocalUser();
            if(!cur || !cur.username) { openAuthModal('signIn'); return; }
            try {
                await remove(ref(db, 'friendRequests/' + toUsername + '/' + cur.username));
            } catch(e){
                console.error('cancelFriendRequest', e);
                alert('Failed to cancel request');
            } finally {
                // optimistic cleanup
                delete outgoingFriendRequests[toUsername];
                renderUserLists();
                renderFriendRequestsUI();
            }
        }

        async function removeFriend(friendName){
            const cur = loadLocalUser();
            if(!cur || !cur.username) { openAuthModal('signIn'); return; }
            if(!confirm(`Remove ${friendName} from friends?`)) return;
            try {
                await remove(ref(db, 'friends/' + cur.username + '/' + friendName));
                await remove(ref(db, 'friends/' + friendName + '/' + cur.username));
                // optional: remove DM history or other references if your app needs it
                // optimistic UI update
                if(friendsSnapshot && friendsSnapshot[friendName]) delete friendsSnapshot[friendName];
                renderUserLists();
            } catch(e){
                console.error('removeFriend', e);
                alert('Failed to remove friend');
            }
        }



        async function acceptFriendRequest(fromUsername){
            const cur = loadLocalUser();
            if(!cur || !cur.username) { openAuthModal('signIn'); return; }
            try{
                // add friendship both ways
                await set(ref(db, 'friends/' + cur.username + '/' + fromUsername), true);
                await set(ref(db, 'friends/' + fromUsername + '/' + cur.username), true);
                // remove the incoming request
                await remove(ref(db, 'friendRequests/' + cur.username + '/' + fromUsername));

                // optimistic local updates + UI refresh so the request doesn't linger
                if(incomingFriendRequests && incomingFriendRequests[fromUsername]) delete incomingFriendRequests[fromUsername];
                if(globalFriendRequests && globalFriendRequests[cur.username] && globalFriendRequests[cur.username][fromUsername]) {
                    delete globalFriendRequests[cur.username][fromUsername];
                }
                // ensure outgoing map is cleared if needed
                if(outgoingFriendRequests && outgoingFriendRequests[fromUsername]) delete outgoingFriendRequests[fromUsername];

                // re-render
                renderFriendRequestsUI();
                renderUserLists();
            }catch(e){ console.error('acceptFriendRequest', e); alert('Failed to accept request'); }
        }


function renderUserLists(){
  const dmContainer = document.getElementById('dmListContainer');
  const rightUsersBody = document.getElementById('rightUsersBody');
  const allContainer = document.getElementById('allUsersContainer'); // left "All Users" (friends only)
  const cur = loadLocalUser();
  const meName = cur?.username || null;

  // --- DM list: only friends (and only those friends that exist in users DB) ---
  if(dmContainer){
    // Build a map of existing rows keyed by username for reuse (preserve badges & data attrs)
    const existing = new Map();
    Array.from(dmContainer.children).forEach(child => {
      const uname = child.dataset.username || (child.querySelector('.dm-friend-name')?.textContent || '').trim();
      if(uname) existing.set(uname, child);
    });

    const keepSet = new Set();

    Object.keys(friendsSnapshot || {}).sort().forEach(friendName => {
      if(!friendName) return;
      keepSet.add(friendName);

      // canonical thread id once
      const threadId = threadIdForDM(meName || '', friendName);

      // presence / typing
      const friendOnlineEntry = Object.values(onlineUsersSnapshot || {}).find(o => String(o.username) === String(friendName));
      const active = friendOnlineEntry && (friendOnlineEntry.lastActive && (Date.now() - friendOnlineEntry.lastActive <= ACTIVE_MS));
      const typingGlob = !!(typingGlobalSnapshot && typingGlobalSnapshot[uidFor(friendName)]);

      let el = existing.get(friendName);

      if(!el){
        // create new row (preserve structure that badges expect)
        el = document.createElement('div');
        el.className = 'dm-friend-item';
        el.dataset.username = friendName;
        el.dataset.threadId = threadId;
        el.innerHTML = `
          <div class="dm-friend-avatar"></div>
          <div class="dm-friend-name">${escapeHtml(friendName)}</div>
        `;
        if(typingGlob){
          const t = document.createElement('div');
          t.className = 'dm-typing';
          t.style.cssText = 'font-size:12px;color:#9ae6b4';
          t.textContent = 'typingâ€¦';
          el.appendChild(t);
        }
        el.addEventListener('click', ()=> openDM(friendName));
        dmContainer.appendChild(el); // append keeps order as we iterate sorted list
      } else {
        // reuse existing element
        el.dataset.threadId = threadId;
        const nameEl = el.querySelector('.dm-friend-name');
        if(nameEl && (nameEl.textContent || '') !== friendName) nameEl.textContent = friendName;
        const typingEl = el.querySelector('.dm-typing');
        if(typingGlob){
          if(!typingEl){
            const t = document.createElement('div');
            t.className = 'dm-typing';
            t.style.cssText = 'font-size:12px;color:#9ae6b4';
            t.textContent = 'typingâ€¦';
            el.appendChild(t);
          }
        } else {
          if(typingEl) typingEl.remove();
        }
        // move element to current position
        dmContainer.appendChild(el);
      }

      // set status indicator + avatar for both new and reused elements
      try {
        const avatarDiv = el.querySelector('.dm-friend-avatar');
        const avatarUrl = getAvatarFor(friendName);
        // ensure there is a status indicator element inside avatarDiv
        let status = avatarDiv.querySelector('.dm-status-indicator');
        if(!status){
          status = document.createElement('div');
          status.className = 'dm-status-indicator';
          status.style.width = '10px';
          status.style.height = '10px';
          status.style.borderRadius = '50%';
          status.style.border = '2px solid #2f3136';
          status.style.position = 'absolute';
          status.style.right = '0';
          status.style.bottom = '0';
          avatarDiv.style.position = 'relative';
          avatarDiv.appendChild(status);
        }
        // status color
        status.style.background = active ? '#3ddc84' : '#6b6e73';

        if(avatarUrl){
          avatarDiv.style.backgroundImage = `url('${avatarUrl}')`;
          avatarDiv.style.backgroundSize = 'cover';
          avatarDiv.style.backgroundPosition = 'center';
          avatarDiv.textContent = '';
        } else {
          avatarDiv.style.backgroundImage = '';
          avatarDiv.style.background = '#5865f2';
          avatarDiv.textContent = friendName.slice(0,2).toUpperCase();
        }
      } catch(e){}
    });

    // remove any stale rows that are no longer friends
    Array.from(existing.keys()).forEach(name => {
      if(!keepSet.has(name)){
        const node = existing.get(name);
        if(node && node.parentNode) node.parentNode.removeChild(node);
        existing.delete(name);
      }
    });
  }

  // --- Right-hand users panel ---
  if(rightUsersBody){
    rightUsersBody.innerHTML = '';
    Object.keys(onlineUsersSnapshot || {}).forEach(uid => {
      const u = onlineUsersSnapshot[uid];
      if(!u) return;
      const displayName = u.username || uid;
      if(displayName === meName) return; // skip self
      const active = (u.lastActive && (Date.now() - u.lastActive <= ACTIVE_MS));
      const typingGlob = !!(typingGlobalSnapshot && typingGlobalSnapshot[uidFor(displayName)]);
      const isFriend = !!(friendsSnapshot && friendsSnapshot[displayName]);

      const row = document.createElement('div');
      row.className = 'user-row';

      // avatar
      const avatarUrl = getAvatarFor(displayName);
      const avatarHtml = avatarUrl
        ? `<div style="position:relative"><div class="avatar" style="background-image:url('${avatarUrl}');background-size:cover;background-position:center;width:36px;height:36px;border-radius:50%"></div><div class="status" style="background:${active? '#3ddc84' : '#6b6e73'};position:absolute;right:-2px;bottom:-2px;width:10px;height:10px;border-radius:50%;border:2px solid #2b2d31"></div></div>`
        : `<div style="position:relative"><div class="avatar" style="background:#5865f2;width:36px;height:36px;border-radius:50%;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:700">${escapeHtml(displayName.slice(0,2).toUpperCase())}</div><div class="status" style="background:${active? '#3ddc84' : '#6b6e73'};position:absolute;right:-2px;bottom:-2px;width:10px;height:10px;border-radius:50%;border:2px solid #2b2d31"></div></div>`;

      row.innerHTML = `
        ${avatarHtml}
        <div class="user-meta">
          <div class="user-name">${escapeHtml(displayName)} ${typingGlob?'<span style="font-weight:500;color:#9ae6b4;margin-left:6px;font-size:12px">typingâ€¦</span>':''}</div>
          <div class="user-sub">${active ? 'Active' : 'Idle'}</div>
        </div>
      `;

      const act = document.createElement('div');
      const me = meName;
      const sentByMe = !!(
        outgoingFriendRequests && outgoingFriendRequests[displayName]
      ) || !!(
        globalFriendRequests &&
        globalFriendRequests[displayName] &&
        globalFriendRequests[displayName][me]
      );

      if(isFriend){
        const removeBtn = document.createElement('button');
        removeBtn.className = 'modal-btn modal-btn-secondary';
        removeBtn.style.height = '28px';
        removeBtn.style.marginLeft = '6px';
        removeBtn.textContent = 'Remove';
        removeBtn.addEventListener('click', (ev)=>{ ev.stopPropagation(); removeFriend(displayName); });
        act.appendChild(removeBtn);
      } else if(sentByMe){
        const sentBtn = document.createElement('button');
        sentBtn.className = 'modal-btn modal-btn-secondary';
        sentBtn.style.height = '28px';
        sentBtn.textContent = 'Sent';
        sentBtn.addEventListener('click', (ev)=>{ ev.stopPropagation(); if(confirm('Cancel friend request?')) cancelFriendRequest(displayName); });
        act.appendChild(sentBtn);
      } else {
        const addBtn = document.createElement('button');
        addBtn.className = 'modal-btn modal-btn-primary';
        addBtn.style.height = '28px';
        addBtn.textContent = 'Add Friend';
        addBtn.addEventListener('click', (ev)=> { ev.stopPropagation(); sendFriendRequest(displayName); });
        act.appendChild(addBtn);
      }

      row.appendChild(act);
      row.addEventListener('click', ()=> openDM(displayName));
      rightUsersBody.appendChild(row);
    });
  }

  // (optional) keep existing "All Users" rendering behavior by calling renderAllUsers if it exists
  try { if(typeof renderAllUsers === 'function') renderAllUsers(/* usersObj param is handled in your implementation */); } catch(e) { /* ignore */ }
}



        function renderAllUsers(usersObj){
            const allContainer = document.getElementById('allUsersContainer');
            const cur = loadLocalUser();
            if(!allContainer) return;
            allContainer.innerHTML = '';
            if(!cur || !cur.username) return;
            Object.keys(friendsSnapshot || {}).sort().forEach(friendName => {
                if(!friendName) return;
                const el = document.createElement('div');
                const onlineEntry = Object.values(onlineUsersSnapshot || {}).find(o => String(o.username) === String(friendName));
                const isOnline = !!onlineEntry;
                if(!userMatchesFilter(friendName)) return; // skip this friend when filtering

                el.className = 'dm-friend-item';
el.innerHTML = `<div class="dm-friend-avatar">...</div>
                <div class="dm-friend-name">${highlightMatch(friendName, userSearchQuery)}</div>`;

                el.addEventListener('click', ()=> openDM(friendName));
                allContainer.appendChild(el);
            });
        }

        /* ----------------- Friend Requests UI rendering ----------------- */
        // ----------------- Friend Requests UI rendering (replace your current function) -----------------
function renderFriendRequestsUI(){
  const cur = loadLocalUser();
  const holder = document.getElementById('frList');
  if(!holder) return;

  holder.innerHTML = '';

  // If not signed-in, show a prompt and clear badge
  if(!cur || !cur.username){
    holder.innerHTML = '<div style="color:#9a9da0">Sign in to see requests</div>';
    // update badge state (no incoming requests for unsigned users)
    incomingFriendRequests = {};
    updateFriendRequestBadge();
    return;
  }

  const keys = Object.keys(incomingFriendRequests || {});
  if(keys.length === 0){
    holder.innerHTML = '<div style="color:#9a9da0">No requests</div>';
    // update badge (ensure it disappears)
    updateFriendRequestBadge();
    return;
  }

  // sort stable: show most recent first if timestamps exist
  keys.sort((a,b)=>{
    const ta = Number(incomingFriendRequests[a] || 0);
    const tb = Number(incomingFriendRequests[b] || 0);
    // newest first
    return (tb - ta) || a.localeCompare(b);
  });

  keys.forEach(fromUser => {
    const row = document.createElement('div');
    row.className = 'fr-item';
    const time = incomingFriendRequests[fromUser] ? new Date(incomingFriendRequests[fromUser]).toLocaleString() : '';
    row.innerHTML = `<div class="fr-left" aria-hidden="false">
                        <div class="fr-avatar">${escapeHtml(String(fromUser).slice(0,2).toUpperCase())}</div>
                        <div class="fr-meta">
                          <div class="fr-name">${escapeHtml(fromUser)}</div>
                          <div class="fr-time">${escapeHtml(time)}</div>
                        </div>
                     </div>
                     <div class="fr-actions">
                        <button class="modal-btn modal-btn-primary" id="accept-${escapeHtml(fromUser)}">Accept</button>
                        <button class="modal-btn modal-btn-secondary" id="ignore-${escapeHtml(fromUser)}">Ignore</button>
                     </div>`;
    holder.appendChild(row);

    // wire up accept/ignore (use event delegation if you prefer)
    const acceptBtn = document.getElementById(`accept-${fromUser}`);
    if(acceptBtn) acceptBtn.addEventListener('click', (e)=>{ e.stopPropagation(); acceptFriendRequest(fromUser); });
    const ignoreBtn = document.getElementById(`ignore-${fromUser}`);
    if(ignoreBtn) ignoreBtn.addEventListener('click', (e)=>{ e.stopPropagation(); remove(ref(db, 'friendRequests/' + cur.username + '/' + fromUser)).catch(()=>{}); });
  });

  // update nav + panel badge
  updateFriendRequestBadge();
}


        /* ----------------- Open conversation UI (channels & DMs) ----------------- */
        function showFriendsList(){
            document.getElementById('friendsListView').style.display='block';
            document.getElementById('channelListView').style.display='none';
            document.getElementById('sidebarHeader').textContent = 'Direct Messages';
            document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
            document.getElementById('navDM').classList.add('active');
            showNoChatSelected();
        }
        function showServerChannels(){
            document.getElementById('friendsListView').style.display='none';
            document.getElementById('channelListView').style.display='block';
            document.getElementById('sidebarHeader').textContent = 'Main Server';
            document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
            document.getElementById('navServer').classList.add('active');
            showNoChatSelected();
        }
        function showNoChatSelected(){
            document.getElementById('chatHeader').innerHTML = '<div class="channel-name">Select a conversation</div>';
            document.getElementById('chatArea').innerHTML = `<div class="no-chat-selected"><div style="padding:18px;">ðŸ‘‹ Choose a friend or channel to start messaging</div></div>`;
            detachActiveThread();
        }



async function openDM(friendName){
  const cur = loadLocalUser();
  if(!cur || !cur.username) { openAuthModal('signIn'); return; }
  const thread = threadIdForDM(cur.username, friendName);
  showFriendsList();

  // create header DOM nodes so we can set avatar via JS
  const header = document.createElement('div');
  header.style.display = 'flex';
  header.style.alignItems = 'center';
  header.style.gap = '12px';

  const avatarDiv = document.createElement('div');
  avatarDiv.className = 'message-avatar';
  avatarDiv.style.width = '32px';
  avatarDiv.style.height = '32px';
  avatarDiv.style.borderRadius = '50%';
  avatarDiv.style.flexShrink = '0';
  // placeholder background (will be updated)
  avatarDiv.style.background = '#5865f2';

  const nameDiv = document.createElement('div');
  nameDiv.className = 'channel-name';
  nameDiv.textContent = friendName;

  header.appendChild(avatarDiv);
  header.appendChild(nameDiv);

  const chatHeader = document.getElementById('chatHeader');
  if(chatHeader) chatHeader.innerHTML = '';
  if(chatHeader) chatHeader.appendChild(header);

  // set avatar if available (synchronously if snapshot exists)
  try {
    const a = getAvatarFor(friendName);
    if(a){
      avatarDiv.style.backgroundImage = `url("${a.replace(/"/g,'\\"')}")`;
      avatarDiv.style.backgroundSize = 'cover';
      avatarDiv.style.backgroundPosition = 'center';
      avatarDiv.textContent = '';
    } else {
      avatarDiv.style.backgroundImage = '';
      avatarDiv.textContent = friendName.slice(0,2).toUpperCase();
    }
  } catch(e){}

  attachThread(thread);
}


        function openChannel(channelName){
            document.getElementById('chatHeader').innerHTML = `<div class="channel-name">#${escapeHtml(channelName)}</div>`;
            // ensure left sidebar shows server channels
            showServerChannels();
            const thread = threadIdForChannel(channelName);
            attachThread(thread);
        }
        
        // ---------------- Right-sidebar user search (debounced, highlights & filters) ----------------
(function rightSidebarUserSearchSetup(){
  const input = document.getElementById('rightUserSearchInput');
  const clearBtn = document.getElementById('rightUserSearchClear');
  const container = document.getElementById('rightUsersBody');
  if(!input || !container) return;

  // re-use your escapeHtml if present, otherwise fallback
  const _escapeHtml = (typeof escapeHtml === 'function') ? escapeHtml : (s => String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'));

  let query = '';

  function highlightMatch(name, q){
    if(!q) return _escapeHtml(name);
    const low = String(name).toLowerCase();
    const idx = low.indexOf(q);
    if(idx === -1) return _escapeHtml(name);
    const before = _escapeHtml(name.slice(0, idx));
    const match = _escapeHtml(name.slice(idx, idx + q.length));
    const after = _escapeHtml(name.slice(idx + q.length));
    return `${before}<span class="right-search-match">${match}</span>${after}`;
  }

  function userMatches(name, q){
    if(!q) return true;
    if(!name) return false;
    return String(name).toLowerCase().includes(q);
  }

  function debounce(fn, wait=180){
    let t = null;
    return function(...args){
      if(t) clearTimeout(t);
      t = setTimeout(()=>{ t = null; fn(...args); }, wait);
    };
  }

  // Apply filter + highlight to currently-rendered rightUsersBody rows
  function applyRightSidebarFilter(){
    const q = String(query || '').trim().toLowerCase();
    const rows = Array.from(container.children);
    rows.forEach(row => {
      try {
        // find display name text (matches how renderUserLists builds row)
        const nameEl = row.querySelector('.user-name');
        if(!nameEl) return; // skip rows without name
        const displayName = (nameEl.dataset && nameEl.dataset.origName) ? nameEl.dataset.origName : (nameEl.textContent || '').trim();

        if(!userMatches(displayName, q)){
          row.style.display = 'none';
        } else {
          row.style.display = '';
          // highlight: store original name on dataset to avoid double-escaping
          if(!nameEl.dataset.origName) nameEl.dataset.origName = displayName;
          nameEl.innerHTML = highlightMatch(displayName, q);
        }
      } catch(e){
        // skip any malformed rows
      }
    });
  }

  // debounced handler for input
  const onInput = debounce((ev)=>{
    query = String(ev.target.value || '').trim().toLowerCase();
    applyRightSidebarFilter();
  }, 160);

  input.addEventListener('input', onInput);
  clearBtn?.addEventListener('click', (ev)=>{
    ev.preventDefault();
    input.value = '';
    query = '';
    input.focus();
    applyRightSidebarFilter();
  });

  // ensure filter reapplies after renderUserLists repopulates the container:
  // use a MutationObserver on the rightUsersBody to re-run filter/highlight.
  const mo = new MutationObserver((mutations)=>{
    // slight debounce to avoid thrash during bulk updates
    setTimeout(() => {
      applyRightSidebarFilter();
    }, 40);
  });
  mo.observe(container, { childList: true, subtree: true });

  // apply once at setup in case the list is already populated
  applyRightSidebarFilter();
})();

        
        // ---------------- Message deletion helper ----------------
async function deleteMessage(threadId, msgKey){
  if(!threadId || !msgKey) return alert('No message selected.');
  const cur = loadLocalUser();
  if(!cur || !cur.username){ openAuthModal('signIn'); return; }

  try {
    const msgRef = ref(db, 'chat/messages/' + threadId + '/' + msgKey);
    const snap = await get(msgRef);
    if(!snap.exists()){
      alert('Message not found (already deleted).');
      return;
    }
    const msg = snap.val();
    // Only allow deletion if you're the author
    if(String(msg.username) !== String(cur.username)){
      alert("You can only delete your own messages.");
      return;
    }
    if(!confirm('Delete this message? This cannot be undone.')) return;

    // optimistic UI: animate remove
    try {
      const dom = document.querySelector(`.message[data-msgkey="${CSS.escape(msgKey)}"]`);
      if(dom){
        dom.classList.add('message-deleting');
        setTimeout(()=>{ try{ dom.remove(); }catch(e){} }, 260);
      }
    }catch(e){}

    // remove from DB
    await remove(msgRef);
    // onValue listener will update the thread when remove completes
  } catch(err){
    console.error('deleteMessage failed', err);
    alert('Failed to delete message.');
  }
}


// ---------------- Attach Delete buttons for messages the current user authored ----------------
function attachMessageDeleteButtons(){
  try {
    const cur = loadLocalUser();
    const myName = cur && cur.username ? String(cur.username) : null;
    // find all message nodes
    const msgs = Array.from(document.querySelectorAll('.message'));
    msgs.forEach(msgEl => {
      const msgKey = msgEl.getAttribute('data-msgkey');
      if(!msgKey) return;

      // if a delete button already exists, skip
      if(msgEl.querySelector('.message-delete-btn')) return;

      // determine author name from rendered DOM (assumes .message-author contains the username)
      const authorEl = msgEl.querySelector('.message-author');
      const authorName = authorEl ? authorEl.textContent : null;

      // only show delete for messages authored by current user
      if(!myName || !authorName || String(myName) !== String(authorName)) return;

      // create actions container if not present
      let actions = msgEl.querySelector('.message-actions');
      if(!actions){
        actions = document.createElement('div');
        actions.className = 'message-actions';
        // append to the message-content area
        const content = msgEl.querySelector('.message-content');
        if(content) content.appendChild(actions);
        else msgEl.appendChild(actions);
      }

      const delBtn = document.createElement('button');
      delBtn.className = 'message-delete-btn';
      delBtn.textContent = 'Delete';
      delBtn.title = 'Delete message';
      // stopPropagation so clicking delete won't trigger other message click handlers
      delBtn.addEventListener('click', (ev) => {
        ev.stopPropagation();
        ev.preventDefault();
        if(!activeThreadId) return alert('No conversation is open.');
        deleteMessage(activeThreadId, msgKey);
      });
      actions.appendChild(delBtn);
    });
  } catch(e){
    console.warn('attachMessageDeleteButtons failed', e);
  }
}


        /* ----------------- sending via UI helpers ----------------- */
        window.openDM = openDM;
        window.openChannel = openChannel;
        window.showFriendsList = showFriendsList;
        window.showServerChannels = showServerChannels;
        window.openAuthModal = openAuthModal;
        window.closeModal = closeModal;
        window.saveSettings = saveSettings;

const bannedWords = [
  "1488","8=D","A55hole","abortion","ahole","AIDS","AIDs","ainujin","ainuzin","akimekura","Anal","anus","anuses",
  "Anushead","anuslick","anuss","aokan","Arsch","Arschloch","arse","arsed","arsehole","arseholed","arseholes","arseholing",
  "arselicker","arses","Ass","asshat","asshole","assholed","assholes","assholing","asslick","asslicker","asses","Auschwitz",
  "b00bs","b00bz","b1tc","Baise","bakachon","bakatyon","Ballsack","Ballzack","BAMF","Bastard","Beaner","Beeatch","beeeyotch",
  "beefwhistle","beeotch","Beetch","beeyotch","Bellend","bestiality","beyitch","beyotch","Biach","bin laden","binladen",
  "biotch","bitch","bitches","Bitching","blad","bladt","blowjob","blow job","blowme","blow me","blyad","blyadt","bon3r","boner",
  "boobs","boobz","Btch","Bukakke","Bullshit","bung","butagorosi","butthead","Butthole","Buttplug","c0ck","Cabron","Cacca",
  "Cadela","Cagada","Cameljockey","Caralho","castrate","Cazzo","ceemen","ch1nk","chankoro","chieokure","chikusatsu","Ching chong",
  "Chinga","Chingada Madre","Chingado","Chingate","chink","chinpo","Chlamydia","choad","chode","chonga","chonko","chonkoro",
  "chourimbo","chourinbo","chourippo","chuurembo","chuurenbo","circlejerk","cl1t","cli7","clit","clitoris","cocain","Cocaine",
  "cock","Cocksucker","Coglione","Coglioni","coitus","coituss","cojelon","cojones","condom","coon","coon hunt","coon kill","coonhunt",
  "coonkill","Cooter","cotton pic","cotton pik","cottonpic","cottonpik","Crackhead","crap","CSAM","Culear","Culero","Culo","Cum",
  "cumming","cun7","cunt","cvn7","cvnt","cyka","d1kc","d4go","dago","Darkie","Deez Nuts","Deez Nutz","deeznut","deeznuts","deeznutz",
  "Dickhead","dick","dicks","dikc","dildo","Dio Bestia","dong","dongs","douche","Downie","Dumass","Dumbass","Durka durka","Dyke",
  "Ejaculate","Encule","enjokousai","enzyokousai","etahinin","etambo","etanbo","f0ck","f0kc","f3lch","facking","fag","faggot","fags",
  "faggots","Fanculo","Fanny","fatass","fck","Fckn","fcuk","fcuuk","felch","fellatio","Fetish","Fgt","FiCKDiCH","Figlio di Puttana",
  "fku","fock","fokc","foreskin","Fotze","Foutre","fucc","fuck","fucks","fuckd","fucked","fucker","fuckers","fucking","fuckr","fuct",
  "fujinoyamai","fukashokumin","Fupa","fuuck","fuuckd","fuucked","fuucker","fuucking","fuuckr","fuuuck","fuuuckd","fuuucked","fuuucker",
  "fuuucking","fuuuckr","fuuuuck","fuuuuckd","fuuuucked","fuuuucker","fuuuucking","fuuuuckr","fuuuuuck","fuuuuuckd","fuuuuucked",
  "fuuuuucker","fuuuuucking","fuuuuuckr","fuuuuuuck","fuuuuuuckd","fuuuuuucked","fuuuuuucker","fuuuuuucking","fuuuuuuckr",
  "fuuuuuuuck","fuuuuuuuckd","fuuuuuuucked","fuuuuuuucker","fuuuuuuucking","fuuuuuuuckr","fuuuuuuuuck","fuuuuuuuuckd",
  "fuuuuuuuucked","fuuuuuuuucker","fuuuuuuuucking","fuuuuuuuuckr","fuuuuuuuuuck","fuuuuuuuuuckd","fuuuuuuuuucked","fuuuuuuuuucker",
  "fuuuuuuuuucking","fuuuuuuuuuckr","fuuuuuuuuuu","fvck","fxck","fxuxcxk","g000k","g00k","g0ok","gestapo","go0k","god damn","goddamn",
  "goldenshowers","golliwogg","gollywog","Gooch","gook","goook","Gyp","h0m0","h0mo","h1tl3","h1tle","hairpie","hakujakusha","hakuroubyo",
  "hakuzyakusya","hantoujin","hantouzin","Herpes","hitl3r","hitler","hitlr","holocaust","hom0","homo","honky","Hooker","hor3","hore",
  "hukasyokumin","Hure","Hurensohn","huzinoyamai","hymen","inc3st","incest","Inculato","Injun","intercourse","inugoroshi","inugorosi",
  "j1g4b0","j1g4bo","j1gab0","j1gabo","Jack Off","jackass","jap","JerkOff","jig4b0","jig4bo","jigabo","Jigaboo","jiggaboo","jizz","Joder",
  "Joto","Jungle Bunny","junglebunny","k k k","k1k3","kichigai","kik3","Kike","kikeiji","kikeizi","Kilurself","kitigai","kkk","klu klux",
  "Klu Klux Klan","kluklux","knobhead","koon hunt","koon kill","koonhunt","koonkill","koroshiteyaru","koumoujin","koumouzin","ku klux klan",
  "kun7","kurombo","Kurva","Kurwa","kxkxk","l3sb0","lesbo","lezbo","lezzie","m07th3rfukr","m0th3rfvk3r","m0th3rfvker","Madonna Puttana",
  "manberries","manko","manshaft","Maricon","Masterbat","masterbate","Masturbacion","masturbait","Masturbare","Masturbate","Masturbazione",
  "Merda","Merde","Meth","Mierda","milf","Minge","MiststÃ¼ck","mitsukuchi","mitukuti","Molest","molester","molestor","Mong","Moon Cricket",
  "moth3rfucer","moth3rfvk3r","moth3rfvker","motherfucker","Mulatto","n1663r","n1664","n166a","n166er","n1g3r","n1German","n1gg3r",
  "n1gGerman","n3gro","n4g3r","n4gg3r","n4gGerman","n4z1","nag3r","nagg3r","nagGerman","natzi","naz1","nazi","nazl","neGerman","ngGerman",
  "nggr","NhigGerman","ni666","ni66a","ni66er","ni66g","ni6g","ni6g6","ni6gg","Nig","nig66","nig6g","nigar","niGerman","nigg3","nigg6",
  "nigga","niggaz","nigGerman","nigger","nigglet","niggr","nigguh","niggur","niggy","niglet","Nignog","nimpinin","ninpinin","Nipples",
  "niqqa","niqqer","Nonce","nugga","Nutsack","Nutted","nygGerman","omeko","Orgy","p3n15","p3n1s","p3ni5","p3nis","p3nl5","p3nls","Paki",
  "Panties","Pedo","pedoph","pedophile","pen15","pen1s","Pendejo","peni5","penile","penis","penl5","penls","penus","Perra","phag","phaggot",
  "phagot","phuck","Pikey","Pinche","Pizda","Polla","Porca Madonna","Porch monkey","Porn","Pornhub","Porra","pr1ck","preteen","prick","pu555y",
  "pu55y","pub1c","Pube","pubic","pun4ni","pun4nl","Punal","punan1","punani","punanl","puss1","puss3","puss5","pusse","pussi","pussy","pussys",
  "Pussies","pusss1","pussse","pusssi","pusssl","pusssy","Pussy","Puta","Putain","Pute","Puto","Puttana","Puttane","Puttaniere","puzzy","pvssy",
  "queef","r3c7um","r4p15t","r4p1st","r4p3","r4pi5t","r4pist","raape","raghead","raibyo","Raip","rap15t","rap1st","Rapage","rape","Raped",
  "rapi5t","Raping","rapist","rectum","Red Tube","Reggin","reipu","retard","Ricchione","rimjob","rimming","rizzape","rompari","Salaud","Salope",
  "sangokujin","sangokuzin","santorum","ScheiÃŸe","Schlampe","schlong","Schwuchtel","Scrote","secks","seishinhakujaku","seishinijo","seisinhakuzyaku",
  "seisinizyo","Semen","semushiotoko","semusiotoko","sh|t","sh|thead","sh|tstain","sh17","sh17head","sh17stain","sh1t","sh1thead","sh1tstain",
  "Shat","Shemale","shi7","shi7head","shi7stain","shinajin","shinheimin","shirakko","shit","shithead","shitstain","shitting","Shitty",
  "shokubutsuningen","sinazin","sinheimin","Skank","slut","SMD","Sodom","sofa king","sofaking","Spanishick","Spanishook","Spanishunk","STD",
  "STDs","Succhia Cazzi","suck my","suckmy","syokubutuningen","Taint","Tapatte","Tapette","Tarlouse","tea bag","teabag","teebag","teensex",
  "teino","Testa di Cazzo","Testicles","Thot","tieokure","tinpo","Tits","Titz","titties","tittiez","tokushugakkyu","tokusyugakkyu","torukoburo",
  "torukojo","torukozyo","tosatsu","tosatu","towelhead","Trannie","Tranny","tunbo","tw47","tw4t","twat","tyankoro","tyonga","tyonko","tyonkoro",
  "tyourinbo","tyourippo","tyurenbo","ushigoroshi","usigorosi","v461n4","v461na","v46in4","v46ina","v4g1n4","v4g1na","v4gin4","v4gina","va61n4",
  "va61na","va6in4","va6ina","Vaccagare","Vaffanculo","Vag","vag1n4","vag1na","vagin4","vagina","VateFaire","vvhitepower","w3tb4ck","w3tback",
  "Wank","wanker","wetb4ck","wetback","wh0r3","wh0re","white power","whitepower","whor3","whore","whores","Wog","Wop","x8lp3t","xbl pet",
  "XBLPET","XBLRewards","Xl3LPET","yabunirami","Zipperhead"
];


// helpers + constants (keeps your original names)
const LEET_MAP = { '0':'o','1':'l','2':'z','3':'e','4':'a','5':'s','6':'g','7':'t','8':'b','9':'g',
  '@':'a','$':'s','!':'i','+':'t','%':'o','#':'h' };

function escapeRegex(s){ return s.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'); }

function normalizeSmartPunctuation(s){
  if(!s) return s;
  return String(s)
    .replace(/[\u2018\u2019\u201A\u201B\u2032]/g,"'")
    .replace(/[\u201C\u201D\u201E\u201F\u2033]/g,'"')
    .replace(/[\u2013\u2014]/g,'-')
    .replace(/\u2026/g,'...')
    .replace(/\u00A0/g,' ');
}

const SWAL_ON_TOP_STYLE_ID = 'swal-on-top-style';
function ensureSwalOnTopStyle(){
  if (typeof document === 'undefined' || !document.getElementById) return;
  if (document.getElementById(SWAL_ON_TOP_STYLE_ID)) return;
  try {
    const style = document.createElement('style');
    style.id = SWAL_ON_TOP_STYLE_ID;
    style.textContent = `
      .swal2-container{position:fixed!important;z-index:2147483646!important;top:0;left:0;right:0;bottom:0;}
      .swal2-backdrop-show{z-index:2147483645!important;}
      .swal2-popup{position:fixed!important;z-index:2147483647!important;}
    `;
    document.head && document.head.appendChild(style);
  } catch (e) { /* ignore */ }
}

function showSwal(opts = {}){
  ensureSwalOnTopStyle();
  try {
    if (typeof Swal !== 'undefined' && Swal && typeof Swal.fire === 'function') {
      const wrapped = Object.assign({}, opts, {
        willOpen: popup => { try{ if (typeof opts.willOpen === 'function') opts.willOpen(popup); }catch(e){} },
        didOpen: popup => { try{ if (typeof opts.didOpen === 'function') opts.didOpen(popup); }catch(e){} }
      });
      return Swal.fire(wrapped).catch(()=>{});
    }
  } catch (e) {}
  return Promise.resolve();
}

function blockedPopup(customText){
  try{
    const text = customText || 'Your message was blocked by the autofilter. Please review your message for inappropriate content.';
    showSwal({
      icon: 'error',
      title: 'Message Blocked',
      text,
      confirmButtonText: 'OK'
    });
  }catch(e){
    try {
      if (typeof window !== 'undefined' && typeof window.alert === 'function') {
        window.alert('Message Blocked: ' + (customText || 'Your message was blocked by the autofilter.'));
      }
    } catch (e2) {}
  }
  return false;
}

// substitutions (conservative)
const SUBSTITUTIONS = [
  ['tion', 'shun'],
  ['sion', 'shun'],
  ['ture', 'chur'],
  ['tch', 'ch'],
  ['cc', 'k'],
  ['ck', 'k'],
  ['ph', 'f'],
  ['qu', 'kw'],
  ['wh', 'w'],
  ['ch', 'sh'],
  ['sh', 'sh'],
  ['igh', 'i'],
  ['e$', ''],
  ['ll','l'], ['ss','s'], ['ff','f'], ['pp','p'], ['rr','r'], ['tt','t'], ['mm','m'], ['nn','n']
];

const SINGLE_LETTER_SUBS = [
  ['c','k'],
  ['x','ks'],
  ['q','k'],
  ['v','f'],
  ['z','s'],
];

function looksObfuscated(word) {
  if(!word) return false;
  if (/[0-9]/.test(word)) return true;
  if (/[^a-z]/.test(word)) return true;
  if (/(.)\1{2,}/.test(word)) return true;
  return false;
}

function compileSubs(list) {
  const sorted = list.slice().sort((a,b) => b[0].length - a[0].length);
  return sorted.map(([from,to]) => {
    const isRegexLike = /[\\^$.*+?()[\\]{}|]/.test(from);
    const re = isRegexLike ? new RegExp(from, 'g') : new RegExp(escapeRegex(from), 'g');
    return { from, to, re, isRegexLike };
  });
}

const COMPILED_SUBS = compileSubs(SUBSTITUTIONS);
const COMPILED_SINGLE = compileSubs(SINGLE_LETTER_SUBS);

function deobfuscate(text, { aggressive = false } = {}){
  if(!text) return '';
  let s = String(text).toLowerCase();

  s = s.split('').map(ch => LEET_MAP[ch] ?? ch).join('');
  const parts = s.split(/(\s+)/);

  for (let i = 0; i < parts.length; i++){
    if (/^\s+$/.test(parts[i])) continue;
    let w = parts[i];

    for (const sub of COMPILED_SUBS) {
      w = w.replace(sub.re, sub.to);
    }

    if (aggressive || looksObfuscated(w)) {
      for (const sub of COMPILED_SINGLE) {
        w = w.replace(sub.re, sub.to);
      }
    }

    w = w.replace(/(.)\1{2,}/g, '$1$1');

    try{ w = w.normalize('NFKD').replace(/[\u0300-\u036f]/g,''); }catch(e){}

    w = w.replace(/[^a-z0-9]+/g,' ').trim();

    parts[i] = w;
  }

  return parts.join('').replace(/\s+/g,' ').trim();
}

function damerauDistance(a,b,maxDist=Infinity){
  if(a===b) return 0;
  const la=a.length, lb=b.length;
  if(Math.abs(la-lb) > maxDist) return maxDist+1;
  if(la===0) return lb;
  if(lb===0) return la;
  const INF = la+lb, da = {};
  const score = Array(la+2).fill(null).map(()=>Array(lb+2).fill(0));
  score[0][0] = INF;
  for(let i=0;i<=la;i++){ score[i+1][1]=i; score[i+1][0]=INF; }
  for(let j=0;j<=lb;j++){ score[1][j+1]=j; score[0][j+1]=INF; }
  for(let i=1;i<=la;i++){
    let db=0;
    for(let j=1;j<=lb;j++){
      const i1 = da[b[j-1]] ?? 0;
      const j1 = db;
      let cost = 1;
      if(a[i-1]===b[j-1]){ cost=0; db=j; }
      score[i+1][j+1] = Math.min(
        score[i][j] + cost,
        score[i+1][j] + 1,
        score[i][j+1] + 1,
        score[i1][j1] + (i - i1 - 1) + 1 + (j - j1 - 1)
      );
    }
    da[a[i-1]] = i;
    if (Math.min(...score[i+1].slice(1, lb+2)) > maxDist) return maxDist+1;
  }
  return score[la+1][lb+1];
}

// ---------- prepare keywords (expects bannedWords in scope) ----------
const rawKeywords = Array.isArray(typeof bannedWords !== 'undefined' ? bannedWords : []) ? (typeof bannedWords !== 'undefined' ? bannedWords : []) : [];
const normalizedKeywords = rawKeywords.map(k => typeof k === 'string' ? deobfuscate(k, { aggressive: true }) : '').filter(Boolean);
const keywordMeta = normalizedKeywords.map(k => ({ token: k, len: k.length }));

function allowedDistanceForLen(len){
  if(len <= 3) return 0;
  if(len <= 6) return 1;
  return 1;
}

// ---------- main diagnosis (preserves function name)
export function diagnoseMessage(text){
  if (typeof text !== 'string') return { blocked: true, reason: 'not-string' };
  if (text.length === 1) return { blocked: false };

  const normalizedInput = normalizeSmartPunctuation(text);

  try {
    const allowedCharsPattern = /^[a-zA-Z0-9 `~!@#$%^&*()\-_=+\[\]{}|;:'",.<>\/?\\\p{Emoji}\s]*$/u;
    if (!allowedCharsPattern.test(normalizedInput)) return { blocked: true, reason: 'unsupported-characters' };
  } catch (e) {
    const fallbackAllowed = /^[a-zA-Z0-9 `~!@#$%^&*()\-_=+\[\]{}|;:'",.<>\/?\\\s]*$/u;
    if (!fallbackAllowed.test(normalizedInput)) return { blocked: true, reason: 'unsupported-characters' };
  }

  const norm = deobfuscate(normalizedInput);

  try {
    if (typeof leoProfanity !== 'undefined' && leoProfanity && typeof leoProfanity.check === 'function') {
      const lpWords = norm.split(/\s+/).filter(Boolean);
      for (const w of lpWords) {
        try {
          if (leoProfanity.check(w)) {
            return { blocked: true, reason: 'leo-profanity', token: w };
          }
        } catch (e) { /* ignore per-word errors */ }
      }
    }
  } catch (e) {}

  try {
    for (const token of normalizedKeywords) {
      if (!token) continue;
      const re = new RegExp(`\\b${escapeRegex(token)}\\b`, 'iu');
      if (re.test(norm)) return { blocked: true, reason: 'exact', token, substring: token };
    }
  } catch (e) {
    console.warn('Exact regex check failed', e);
  }

  const words = norm.split(/\s+/).filter(Boolean);
  const FUZZY_ALLOWLIST = new Set(['shot','headshot','headshots','platform','proof','ambition','persistence']);

  for (const { token, len } of keywordMeta) {
    if (!token) continue;
    const allowed = allowedDistanceForLen(len);
    if (allowed === 0) continue;
    const minLen = Math.max(1, len - allowed);
    const maxLen = len + allowed;
    for (const w of words) {
      if (w.length < minLen) continue;
      const endLimit = w.length - minLen;
      for (let i = 0; i <= endLimit; i++) {
        for (let L = minLen; L <= maxLen; L++) {
          if (i + L > w.length) break;
          const sub = w.substring(i, i + L);
          if (FUZZY_ALLOWLIST.has(sub)) continue;
          if (!(i === 0 || i + L === w.length)) continue;
          if (token[0] !== sub[0] || token[token.length-1] !== sub[sub.length-1]) continue;
          const dist = damerauDistance(token, sub, allowed);
          if (dist <= allowed) return { blocked: true, reason: 'fuzzy', token, substring: sub, distance: dist };
        }
      }
    }
  }

  return { blocked: false };
}

// ------------------------ Masking / sanitization helpers ------------------------
function makeAsterisks(len){
  return '*'.repeat(Math.max(1, len));
}

function maskInsensitive(input, pattern){
  if (!pattern || !input) return input;
  try {
    const re = new RegExp(escapeRegex(pattern), 'ig');
    return input.replace(re, (m) => makeAsterisks(m.length));
  } catch (e) {
    return input.split(pattern).join(makeAsterisks(pattern.length));
  }
}

// preserve function name sanitizeMessage
export function sanitizeMessage(text){
  if (typeof text !== 'string' || text.length === 0) return text;

  const normalizedInput = normalizeSmartPunctuation(text);
  let sanitized = String(text);

  let diag = null;
  try {
    diag = diagnoseMessage(text);
  } catch (e) {
    diag = null;
  }

  if (diag && diag.blocked) {
    if (diag.substring) {
      sanitized = maskInsensitive(sanitized, diag.substring);
    }
    if (diag.token) {
      sanitized = maskInsensitive(sanitized, diag.token);
    }
    if (diag.reason === 'leo-profanity' && diag.token) {
      sanitized = maskInsensitive(sanitized, diag.token);
    }
  }

  try {
    for (const raw of rawKeywords) {
      if (!raw || typeof raw !== 'string') continue;
      const trimmed = raw.trim();
      if (!trimmed) continue;
      try {
        const wordy = /^\w+$/.test(trimmed);
        if (wordy) {
          const re = new RegExp(`\\b${escapeRegex(trimmed)}\\b`, 'ig');
          sanitized = sanitized.replace(re, (m) => makeAsterisks(m.length));
        } else {
          sanitized = maskInsensitive(sanitized, trimmed);
        }
      } catch (e) {
        sanitized = maskInsensitive(sanitized, trimmed);
      }
    }
  } catch (e) {}

  try {
    if (typeof leoProfanity !== 'undefined' && leoProfanity && typeof leoProfanity.check === 'function') {
      const norm = deobfuscate(normalizedInput);
      const words = norm.split(/\s+/).filter(Boolean);
      for (const w of words) {
        try {
          if (leoProfanity.check(w)) {
            sanitized = maskInsensitive(sanitized, w);
          }
        } catch (e) {}
      }
    }
  } catch (e) {}

  return sanitized;
}

// preserve function name filterOrMaskMessage
export function filterOrMaskMessage(text){
  const diag = diagnoseMessage(text);
  if (!diag || !diag.blocked) {
    return { allowed: true, text, reason: null };
  }

  if (diag.reason === 'unsupported-characters') {
    try {
      if (diag.token) {
        blockedPopup(`Your message was blocked by the autofilter (matched "${diag.token}"). Please review your message.`);
      } else {
        blockedPopup();
      }
    } catch (e) {}
    return { allowed: false, text, reason: diag.reason };
  }

  const sanitized = sanitizeMessage(text);

  // silent by default â€” uncomment to notify user visually:
  // showSwal({ icon: 'info', title: 'Message sanitized', text: 'Potentially inappropriate words were replaced with asterisks.' });

  return { allowed: true, text: sanitized, reason: diag.reason || null };
}

// preserve function name isMessageClean
export function isMessageClean(text){
  const res = diagnoseMessage(text);
  if (res.blocked) {
    try {
      if (res.token) {
        blockedPopup(`Your message was blocked by the autofilter (matched "${res.token}"). Please review your message.`);
      } else {
        blockedPopup();
      }
    } catch (e) {}
    return false;
  }
  return true;
}

// optional attach to window for debugging (does not rename functions)
try {
  if (typeof window !== 'undefined') {
    window.diagnoseMessage = diagnoseMessage;
    window.isMessageClean = isMessageClean;
    window.sanitizeMessage = sanitizeMessage;
    window.filterOrMaskMessage = filterOrMaskMessage;
  }
} catch (e) {}


async function sendMessageToActiveThread(text, image){
    if(!activeThreadId) return alert('No conversation open.');
    const cur = loadLocalUser();
    if(!cur || !cur.username) return openAuthModal('signIn');

    // global cooldown check
    const nowTs = Date.now();
    const lastTs = getLastGlobalSendTs();
    const age = nowTs - lastTs;
    if(age < GLOBAL_CHAT_DELAY_MS){
        const waitMs = GLOBAL_CHAT_DELAY_MS - age;
        // friendly message to user
        alert(`You're sending messages too quickly. Please wait ${Math.ceil(waitMs/1000 * 10)/10} seconds.`);
        return;
    }

    // size check (apply to raw text + optional dataURL image)
    const bytes = computeMessageSize(String(text || ''), image);
    if(bytes > SEND_LIMIT_BYTES){
        const kb = Math.round(bytes / 512);
        const limitKb = Math.round(SEND_LIMIT_BYTES / 512);
        alert(`Message too large (${kb} KB). Maximum allowed send size is ${limitKb} KB.`);
        return;
    }

    const threadRef = ref(db, 'chat/messages/' + activeThreadId);
    const payload = { username: cur.username, text: String(text || ''), ts: serverTimestamp() };
    if(image) payload.image = image;

    // set last-send timestamp immediately (prevents quick double-sends)
    // if send fails we'll revert to previous timestamp in the catch block
    const prevTs = lastTs;
    try {
        setLastGlobalSendTs(nowTs);
        await push(threadRef, payload);
        // clear input and typing flag
        const inp = document.getElementById('activeMessageInput');
        if(inp) inp.value = '';
        setTyping(false);
    } catch(err){
        // revert last-send ts on failure
        try { setLastGlobalSendTs(prevTs); } catch(e){}
        console.error('sendMessageToActiveThread failed', err);
        alert('Failed to send message. Try again.');
    }
}



        
        // ---------------- Send limits & global chat delay ----------------
// Put these near your other constants / helpers.
const SEND_LIMIT_BYTES = 500 * 1024;            // 500 KB
const GLOBAL_CHAT_DELAY_MS = 1000;              // 2 seconds
const LAST_SEND_KEY = 'chat_last_global_send_ts_v1';

// last send timestamp helpers (persist in localStorage so swapping threads or refresh still respects delay)
function getLastGlobalSendTs(){
  return Number(localStorage.getItem(LAST_SEND_KEY) || '0');
}
function setLastGlobalSendTs(ts){
  try { localStorage.setItem(LAST_SEND_KEY, String(ts)); } catch(e){}
}

// compute approximate byte-size of a plain text + optional dataURL image payload
function computeMessageSize(text, imageDataUrl){
  let bytes = 0;
  try {
    if(text){
      // UTF-8 bytes
      if(typeof TextEncoder !== 'undefined'){
        bytes += new TextEncoder().encode(String(text)).length;
      } else {
        // fallback naive estimate (1 char = 1 byte)
        bytes += String(text).length;
      }
    }
    if(imageDataUrl){
      // imageDataUrl likely "data:<mime>;base64,<b64data>" â€” use base64 length to approximate bytes
      const comma = String(imageDataUrl).indexOf(',');
      const b64 = comma >= 0 ? imageDataUrl.slice(comma + 1) : imageDataUrl;
      // base64 -> bytes: (len * 3) / 4, but account for padding
      const len = b64 ? b64.replace(/\s/g,'').length : 0;
      bytes += Math.round((len * 3) / 4);
    }
  } catch(e) {
    console.warn('computeMessageSize failed', e);
  }
  return bytes;
}


// pending avatar dataURL for the settings modal
let pendingAvatarDataUrl = null;

function openSettings(){
  const cur = loadLocalUser();
  document.getElementById('settingsModal').style.display = 'flex';
  const usernameEl = document.getElementById('settingsUsername');
  const passwordEl = document.getElementById('settingsPassword');
  const msgEl = document.getElementById('settingsMessage');
  const authActionBtn = document.getElementById('authActionButton');
  msgEl.textContent = ''; msgEl.className = '';

  // ensure a dedicated avatar row exists in the modal (idempotent)
  try {
    const settingsBody = document.getElementById('settingsBody');
    if(settingsBody && !document.getElementById('settingsAvatarRow')){
      const row = document.createElement('div');
      row.id = 'settingsAvatarRow';
      row.style.display = 'flex';
      row.style.gap = '12px';
      row.style.alignItems = 'center';
      row.style.marginBottom = '12px';

      row.innerHTML = `
        <div id="settingsAvatarPreview" style="width:64px;height:64px;border-radius:8px;background:#5865f2;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:700"></div>
        <div style="flex:1">
          <div style="font-weight:700;margin-bottom:6px;color:#b9bbbe">Profile Picture</div>
          <div style="font-size:13px;color:#9a9da0;margin-bottom:8px">Upload an image (will be resized). PNG/JPG preferred.</div>
          <div style="display:flex;gap:8px;align-items:center">
            <input id="settingsAvatarFile" type="file" accept="image/*" style="display:inline-block" />
            <button id="settingsAvatarRemove" class="modal-btn modal-btn-secondary" style="height:32px;padding:6px 10px">Remove</button>
          </div>
        </div>
      `;
      // insert near top of settings body
      settingsBody.insertBefore(row, settingsBody.firstChild);
    }
  } catch(e){ console.warn('openSettings avatar row create failed', e); }

  // populate fields
  if(cur && cur.username){
      passwordEl.value = cur.password ? b64Decode(cur.password) : '';
      authActionBtn.textContent = 'Sign Out';
      authActionBtn.onclick = () => {
          if(confirm('Are you sure?')){
              try { signOut(); } catch(e){ console.warn(e); }
              closeModal();
          }
      };
  } else {
      usernameEl.value = '';
      passwordEl.value = '';
      authActionBtn.textContent = 'Sign In';
      authActionBtn.onclick = () => { closeModal(); openAuthModal('signIn'); };
  }

  // wire avatar controls (idempotent)
  try {
    const avatarPreview = document.getElementById('settingsAvatarPreview');
    const avatarFile = document.getElementById('settingsAvatarFile');
    const removeBtn = document.getElementById('settingsAvatarRemove');

    // show current avatar from DB if available
    pendingAvatarDataUrl = null;
    if(avatarPreview){
      const curAvatar = cur && cur.username ? getAvatarFor(cur.username) : null;
      if(curAvatar){
        avatarPreview.style.backgroundImage = `url('${curAvatar}')`;
        avatarPreview.style.backgroundSize = 'cover';
        avatarPreview.style.backgroundPosition = 'center';
        avatarPreview.textContent = '';
      } else {
        avatarPreview.style.backgroundImage = '';
        avatarPreview.style.background = '#5865f2';
        avatarPreview.textContent = (cur && cur.username) ? String(cur.username).slice(0,2).toUpperCase() : '';
      }
    }

    // file -> dataURL handler
    if(avatarFile && !avatarFile._wired){
      avatarFile._wired = true;
      avatarFile.addEventListener('change', async (ev) => {
        const f = ev.target.files && ev.target.files[0];
        if(!f) return;
        if(!f.type.startsWith('image/')) { alert('Please choose an image file.'); avatarFile.value = ''; return; }
        try {
          // reuse your existing imageFileToDataURL helper for resizing
          const dataURL = await imageFileToDataURL(f, 800, 0.72);
          pendingAvatarDataUrl = dataURL;
          if(avatarPreview){
            avatarPreview.style.backgroundImage = `url('${dataURL}')`;
            avatarPreview.style.backgroundSize = 'cover';
            avatarPreview.style.backgroundPosition = 'center';
            avatarPreview.textContent = '';
          }
        } catch(err){
          console.warn('avatar processing failed', err);
          alert('Failed to process image. Try a smaller one.');
        } finally {
          avatarFile.value = '';
        }
      });
    }

    if(removeBtn && !removeBtn._wired){
      removeBtn._wired = true;
      removeBtn.addEventListener('click', (ev) => {
        ev.stopPropagation();
        pendingAvatarDataUrl = null;
        if(avatarPreview){
          avatarPreview.style.backgroundImage = '';
          avatarPreview.style.background = '#5865f2';
          avatarPreview.textContent = (cur && cur.username) ? String(cur.username).slice(0,2).toUpperCase() : '';
        }
      });
    }
  } catch(e){ console.warn('openSettings avatar wiring failed', e); }
}

        function closeModal(){ document.querySelectorAll('.modal').forEach(m => m.style.display = 'none'); }
        document.getElementById('toggleSettingsPassword').addEventListener('click', ()=>{
            const pwd = document.getElementById('settingsPassword'), btn = document.getElementById('toggleSettingsPassword');
            if(pwd.type==='password'){ pwd.type='text'; btn.textContent='Hide'; } else { pwd.type='password'; btn.textContent='Show'; }
        });
        
        

// Cooldown (ms)
const USERNAME_CHANGE_COOLDOWN = 30 * 60 * 1000; // 30 minutes


// Defensive, verbose loadSettings to match saveSettingsVerbose
async function loadSettings() {
    console.log('loadSettingsVerbose: start');

    try {
        // Detect firebase helpers like in saveSettingsVerbose
        const refFn = (typeof dbRef === 'function') ? dbRef
                      : (typeof ref === 'function') ? ref
                      : null;
        const getFn = (typeof get === 'function') ? get : null;

        // Get local/current user
        const cur = (typeof loadLocalUser === 'function') ? loadLocalUser() : null;
        if (!cur || !cur.username) {
            console.warn('loadSettingsVerbose: no local user, showing sign-in');
            if (typeof openAuthModal === 'function') openAuthModal('signIn');
            return;
        }
        console.log('loadSettingsVerbose: local user', cur);

        // DOM elements (be permissive about IDs)
        const usernameEl = document.getElementById('settingsUsername')
                        || document.getElementById('settings-username');
        const passwordEl = document.getElementById('settingsPassword')
                        || document.getElementById('settings-password');
        const avatarFileEl = document.getElementById('settingsAvatarFi')
                        || document.getElementById('settingsAvatarFile')
                        || document.getElementById('settings-avatar-file');
        const avatarPreviewEl = document.getElementById('settingsAvatarPreview')
                        || document.getElementById('settingsAvatarImg')
                        || document.getElementById('settings-avatar-preview');

        if (!usernameEl) { console.warn('loadSettingsVerbose: username input not found'); }
        if (!passwordEl) { console.warn('loadSettingsVerbose: password input not found'); }

        let userData = null;

        // Prefer loading from Firebase if helpers exist and database is present
        if (window.database && refFn && getFn) {
            try {
                console.log('loadSettingsVerbose: attempting to load user from Firebase:', cur.username);
                const userRef = refFn(window.database, 'users/' + cur.username);
                const snap = await getFn(userRef);
                if (snap && typeof snap.exists === 'function' ? snap.exists() : !!snap) {
                    userData = snap.val ? snap.val() : snap;
                    console.log('loadSettingsVerbose: loaded userData from Firebase', userData);
                } else {
                    console.warn('loadSettingsVerbose: user node not found on server, using local user object', {cur, snap});
                }
            } catch (err) {
                console.error('loadSettingsVerbose: error reading from Firebase', err);
                // fall back to local
            }
        } else {
            console.log('loadSettingsVerbose: Firebase unavailable, falling back to local user');
        }

        // If no firebase data, use local user object
        if (!userData) {
            userData = cur || {};
        }

        // Populate DOM fields
        if (usernameEl) {
            // show the username the app expects (local username)
            usernameEl.value = (userData.username || cur.username || '');
        }
        if (passwordEl) {
            // stored password is base64 (btoa) â€” try to decode for UX, otherwise leave blank
            const stored = userData.password;
            if (stored) {
                try {
                    passwordEl.value = atob(stored);
                    console.log('loadSettingsVerbose: decoded password into field');
                } catch (e) {
                    console.warn('loadSettingsVerbose: atob failed for stored password, leaving password blank', e);
                    passwordEl.value = '';
                }
            } else {
                passwordEl.value = '';
            }
        }

        // Avatar preview: if we have a dataURL in userData.avatar, show it
        if (avatarPreviewEl) {
            if (userData.avatar) {
                avatarPreviewEl.src = userData.avatar;
                // If it's an <img>, ensure it's visible
                if (avatarPreviewEl.tagName && avatarPreviewEl.tagName.toLowerCase() === 'img') {
                    avatarPreviewEl.style.display = '';
                }
                console.log('loadSettingsVerbose: set avatar preview from userData.avatar (length)', userData.avatar.length);
            } else {
                // keep existing preview or hide
                avatarPreviewEl.src = '';
                avatarPreviewEl.style.display = 'none';
                console.log('loadSettingsVerbose: no avatar found in userData');
            }
        }

        // Clear file input (we don't auto-fill file inputs)
        if (avatarFileEl && avatarFileEl.value) {
            try { avatarFileEl.value = ''; } catch (e) { console.warn('loadSettingsVerbose: could not clear file input', e); }
        }

        console.log('loadSettingsVerbose: finished successfully', {userData});
        return userData;

    } catch (err) {
        console.error('loadSettingsVerbose: unexpected error', err);
        try { showSwal && showSwal('Error loading settings: ' + (err && err.message ? err.message : String(err))); } catch(e) {}
    }
}

// ---------- Defensive saveSettings (replace the original) ----------
async function saveSettings(){
  try {
    const cur = (typeof loadLocalUser === 'function') ? loadLocalUser() : null;
    if(!cur || !cur.username){ closeModal && closeModal(); if(typeof openAuthModal === 'function') openAuthModal('signIn'); return; }

    const pwdEl = document.getElementById('settingsPassword');
    if(!pwdEl){
      console.warn('saveSettings: settingsPassword element missing');
      document.getElementById('settingsMessage') && (document.getElementById('settingsMessage').textContent = 'Internal error: password input missing.');
      return;
    }
    const newPass = String(pwdEl.value || '');
    if(!newPass){
      const msgEl = document.getElementById('settingsMessage');
      if(msgEl){ msgEl.className='error'; msgEl.textContent='Password cannot be empty.'; }
      return;
    }
    const encoded = (typeof b64Encode === 'function') ? b64Encode(newPass) : btoa(newPass);

    // prepare updates
    const updates = {};
    updates['users/' + cur.username + '/password'] = encoded;

    // pendingAvatarDataUrl may be managed elsewhere; guard-read it
    if(typeof pendingAvatarDataUrl !== 'undefined'){
      if(pendingAvatarDataUrl === null){
        updates['users/' + cur.username + '/avatar'] = null;
      } else if(pendingAvatarDataUrl){
        updates['users/' + cur.username + '/avatar'] = pendingAvatarDataUrl;
      }
    }

    // perform update (defensive: ensure ref/update exist)
    if(typeof update !== 'function' || typeof ref !== 'function' || typeof db === 'undefined'){
      console.error('saveSettings: firebase helpers missing');
      const msgEl = document.getElementById('settingsMessage');
      if(msgEl){ msgEl.className='error'; msgEl.textContent='Save failed: backend unavailable.'; }
      return;
    }

    try {
      await update(ref(db), updates);
    } catch(e){
      console.error('saveSettings: DB update failed', e);
      const msgEl = document.getElementById('settingsMessage');
      if(msgEl){ msgEl.className='error'; msgEl.textContent='Save failed.'; }
      return;
    }

    // on success, update local storage & in-memory caches and UI
    try {
      saveLocalUser && saveLocalUser({ username: cur.username, password: encoded });
    } catch(e){ console.warn('saveLocalUser failed', e); }

    try {
      const msgEl = document.getElementById('settingsMessage');
      if(msgEl){ msgEl.className='success'; msgEl.textContent='Saved.'; }
    } catch(e){}

    // optimistic usersSnapshot update
    try {
      if(!usersSnapshot[cur.username]) usersSnapshot[cur.username] = {};
      if(updates['users/' + cur.username + '/avatar'] === null){
        delete usersSnapshot[cur.username].avatar;
      } else if(updates['users/' + cur.username + '/avatar']){
        usersSnapshot[cur.username].avatar = updates['users/' + cur.username + '/avatar'];
      }
    } catch(e){ console.warn('usersSnapshot update failed', e); }

    // refresh UI in a safe manner
    try { safeUpdateUIForUser(cur.username); } catch(e){ console.warn('safeUpdateUIForUser failed', e); }
    try { renderUserLists && renderUserLists(); } catch(e){ console.warn('renderUserLists failed', e); }
    try { renderMessagesForActiveThread && typeof renderMessagesForActiveThread === 'function' && renderMessagesForActiveThread([]); } catch(e){ /* ignore */ }

    // done
    console.log('saveSettings: done');
  } catch(err){
    console.error('saveSettings: unexpected error', err);
    const msgEl = document.getElementById('settingsMessage');
    if(msgEl){ msgEl.className='error'; msgEl.textContent='Save failed (see console).'; }
  }
}


function saveLocalUser(user) {
    localStorage.setItem('LOCAL_KEY', JSON.stringify(user));
}
function loadLocalUser() {
    try {
        const data = localStorage.getItem('LOCAL_KEY');
        return data ? JSON.parse(data) : null;
    } catch {
        return null;
    }
}




        document.getElementById('settingsSaveBtn').addEventListener('click', saveSettings);

        // close modals when clicking outside
        window.addEventListener('click', (e)=>{ if(e.target.classList && e.target.classList.contains('modal')) closeModal(); });

/* ---------- Client version enforcement & manual delete tool ---------- */

// CLIENT version string (change when you release new builds)
const CLIENT_VERSION = "v1.0";

// Interval handle (so we can clear it when enforcing)
let __versionCheckInterval = null;

// Try several DB paths that might contain the current server version.
// This will return the first string it finds, or null if nothing found.
async function fetchServerVersion(){
  try {
    const candidates = [
      'Update',            // your example
      'app/version',
      'meta/version',
      'update/version',
      'config/version'
    ];
    for(const p of candidates){
      try {
        const snap = await get(ref(db, p));
        if(snap && snap.exists()){
          const val = snap.val();
          if(typeof val === 'string' && val.trim().length) return val.trim();
          // support object { version: 'v1.2' }
          if(val && typeof val === 'object' && typeof val.version === 'string' && val.version.trim()) return val.version.trim();
        }
      } catch(e){
        // ignore single-path errors and continue trying others
        console.warn('fetchServerVersion path failed', p, e);
      }
    }
  } catch(e){
    console.warn('fetchServerVersion failed', e);
  }
  return null;
}

// Create a full-screen overlay that instructs the user to refresh.
// Also try to gracefully stop live listeners / presence.
function enforceUpdateScreen(serverVersion){
  try {
    // stop the periodic checks
    if(__versionCheckInterval){ clearInterval(__versionCheckInterval); __versionCheckInterval = null; }

    // try to stop presence and thread listeners (best-effort)
    try { stopPresenceImmediate(); } catch(e){ /* ignore */ }
    try { detachActiveThread(); } catch(e){ /* ignore */ }
    try { stopChatListeners(); } catch(e){ /* ignore */ }

    // remove any transient popups/pickers
    try { closeGifPicker(); } catch(e) {}
    try { closeEmojiPickerPopup(); } catch(e) {}
    try { closeEmojiPicker(); } catch(e) {}

    // Create overlay
    if(document.getElementById('update-overlay')) return;
    const overlay = document.createElement('div');
    overlay.id = 'update-overlay';
    overlay.style.position = 'fixed';
    overlay.style.left = '0';
    overlay.style.top = '0';
    overlay.style.right = '0';
    overlay.style.bottom = '0';
    overlay.style.zIndex = '99999';
    overlay.style.background = 'linear-gradient(180deg, rgba(22,22,24,0.95), rgba(22,22,24,0.98))';
    overlay.style.display = 'flex';
    overlay.style.alignItems = 'center';
    overlay.style.justifyContent = 'center';
    overlay.style.flexDirection = 'column';
    overlay.style.color = '#fff';
    overlay.style.fontFamily = 'sans-serif';
    overlay.innerHTML = `
      <div style="max-width:720px;text-align:center;padding:28px;border-radius:12px;">
        <h2 style="margin-bottom:8px;font-size:20px">Update available</h2>
        <p style="margin:0 0 16px;color:#d0d0d0">
          Your client (version ${escapeHtml(CLIENT_VERSION)}) does not match the server version${serverVersion ? ` (${escapeHtml(serverVersion)})` : ''}.
          Please refresh the page to get the latest update.
        </p>
        <div style="display:flex;gap:8px;justify-content:center;margin-top:14px;">
          <button id="updateRefreshBtn" class="modal-btn modal-btn-primary" style="height:40px;padding:8px 16px;background:#5865f2;color:#fff;border-radius:8px;border:none;cursor:pointer">Refresh now</button>
          <button id="updateCopyBtn" class="modal-btn modal-btn-secondary" style="height:40px;padding:8px 16px;border-radius:8px;border:none;cursor:pointer">Copy server version</button>
        </div>
        <div style="margin-top:12px;color:#b9bbbe;font-size:13px">If refresh doesn't work, try a hard reload (Ctrl+Shift+R / Cmd+Shift+R).</div>
      </div>
    `;
    document.documentElement.appendChild(overlay);

    document.getElementById('updateRefreshBtn')?.addEventListener('click', ()=> location.reload(true));
    document.getElementById('updateCopyBtn')?.addEventListener('click', ()=>{
      try { navigator.clipboard.writeText(serverVersion || 'unknown'); alert('Server version copied'); } catch(e){ alert('Copy failed â€” server version: ' + (serverVersion||'unknown')); }
    });

    // Clear the rest of the page content under the overlay (best-effort)
    try {
      const app = document.querySelector('.app-container');
      if(app) app.style.filter = 'blur(2px) brightness(.6)';
    } catch(e) {}
  } catch(e){
    console.warn('enforceUpdateScreen failed', e);
  }
}

// Check server version and enforce overlay if mismatch found
async function checkClientVersionAndEnforce(){
  try {
    const serverVer = await fetchServerVersion();
    if(serverVer && String(serverVer) !== String(CLIENT_VERSION)){
      console.warn('Client version mismatch â€” server:', serverVer, 'client:', CLIENT_VERSION);
      enforceUpdateScreen(serverVer);
      return true;
    }
    return false;
  } catch(e){
    console.warn('checkClientVersionAndEnforce failed', e);
    return false;
  }
}

// Start periodic checking (call this once on boot)
function startVersionChecking(){
  // run immediately
  checkClientVersionAndEnforce();
  // then every 30s
  if(__versionCheckInterval) clearInterval(__versionCheckInterval);
  __versionCheckInterval = setInterval(()=> {
    checkClientVersionAndEnforce().catch ? checkClientVersionAndEnforce().catch(()=>{}) : void 0;
  }, 30 * 1000);
}

// Kick off version checking now (also safe to call again)
try { startVersionChecking(); } catch(e) { console.warn('startVersionChecking failed', e); }

/* ---------- Manual delete of user's last N messages in active thread ---------- */

// Confirm prompt + delete function. Only deletes messages authored by current user.
async function deleteMyLastNMessagesInThread(threadId, n){
  try {
    n = Number(n) || 0;
    if(!threadId) return alert('No conversation open.');
    if(n <= 0) return alert('Please enter a positive number.');

    const cur = loadLocalUser();
    if(!cur || !cur.username) { openAuthModal('signIn'); return; }

    if(!confirm(`Delete your last ${n} message${n===1?'':'s'} in this conversation? This cannot be undone.`)) return;

    // fetch messages for this thread
    const snap = await get(ref(db, 'chat/messages/' + threadId));
    if(!snap || !snap.exists()){
      alert('No messages found in this conversation.');
      return;
    }
    const msgs = snap.val();
    // collect messages authored by current user
    const arr = Object.keys(msgs).map(k => {
      const m = msgs[k] || {};
      const ts = (typeof m.ts === 'number') ? m.ts : Number(m.ts || 0);
      return { key: k, ts, username: m.username };
    }).filter(item => String((item.username||'')).toLowerCase() === String(cur.username).toLowerCase());

    if(arr.length === 0){
      alert('No messages by you found in this conversation.');
      return;
    }

    // sort by ts descending (newest first)
    arr.sort((a,b) => (b.ts || 0) - (a.ts || 0));
    const toDelete = arr.slice(0, n);

    // delete sequentially (safer on DB); you can change to Promise.all if you prefer parallel.
    let deleted = 0;
    for(const item of toDelete){
      try {
        await remove(ref(db, 'chat/messages/' + threadId + '/' + item.key));
        deleted++;
      } catch(e){
        console.warn('Failed to remove message', item, e);
      }
    }

    alert(`Deleted ${deleted} message${deleted===1 ? '' : 's'}.`);
  } catch(e){
    console.error('deleteMyLastNMessagesInThread failed', e);
    alert('Delete failed. See console for details.');
  }
}

// Inject a small "Delete my last N msgs" button into the message-input area (idempotent)
function injectManualDeleteControl(){
  try {
    const container = document.querySelector('.message-input-container');
    if(!container) return;
    if(document.getElementById('manualDeleteBtn')) return; // already added

    const btn = document.createElement('button');
    btn.id = 'manualDeleteBtn';
    btn.className = 'modal-btn modal-btn-secondary';
    btn.style.height = '40px';
    btn.style.padding = '8px 12px';
    btn.style.marginLeft = '6px';
    btn.textContent = 'Delete my last N msgs';
    btn.title = 'Delete your last N messages in the currently open conversation';

    btn.addEventListener('click', async (ev) => {
      ev.stopPropagation();
      ev.preventDefault();
      if(!activeThreadId) return alert('Open a conversation first.');
      const raw = prompt('How many of your most recent messages to delete? Enter a number (e.g. 5):', '5');
      if(raw === null) return;
      const n = parseInt(raw, 10);
      if(isNaN(n) || n <= 0) return alert('Invalid number.');
      // perform delete
      await deleteMyLastNMessagesInThread(activeThreadId, n);
    });

    // Insert near the end but before the input so it doesn't break layout
    const rightGroup = document.createElement('div');
    rightGroup.style.display = 'flex';
    rightGroup.style.gap = '8px';
    rightGroup.appendChild(btn);

    // try to append to the existing button group inside message-input-container
    // prefer not to disturb current layout: insert before the text input if possible
    const inputEl = container.querySelector('.message-input');
    if(inputEl && inputEl.parentNode){
      inputEl.parentNode.appendChild(rightGroup);
    } else {
      container.appendChild(rightGroup);
    }
  } catch(e){
    console.warn('injectManualDeleteControl failed', e);
  }
}

// Ensure control exists whenever messages UI is mounted (call after rendering messages)
(function ensureManualDeleteControlHook(){
  // If renderMessagesForActiveThread exists, wrap a small post-hook
  try {
    if (typeof renderMessagesForActiveThread === 'function') {
      const orig = renderMessagesForActiveThread;
      renderMessagesForActiveThread = function(list){
        // call original
        orig.call(this, list);
        // then inject control
        try { injectManualDeleteControl(); } catch(e){ console.warn(e); }
      };
    } else {
      // fallback: try to inject after a short delay (best-effort)
      setTimeout(() => { injectManualDeleteControl(); }, 800);
    }
  } catch(e){
    console.warn('ensureManualDeleteControlHook failed', e);
  }
})();

// run a check immediately on script load (in addition to interval)
try { checkClientVersionAndEnforce(); } catch(e){ /* ignore */ }



        /* ----------------- Boot: check auth and presence ----------------- */
        async function checkLocalAuthAndBoot(){
            const cur = loadLocalUser();
            if(cur && cur.username && cur.password){
                try {
                    const user = await getUser(cur.username);
                    if(!user) { clearLocalUser(); openAuthModal('signIn'); return; }
                    if(user.password !== cur.password){ clearLocalUser(); openAuthModal('signIn'); return; }
                    updateUIForUser(cur.username);
                    startPresence(cur.username);
                    if(user.password === cur.password){
  updateUIForUser(cur.username);
  startPresence(cur.username);
  // ensure avatars for current user also present in UI
  setTimeout(()=>{ try{ updateAvatarsInUI(); }catch(e){} }, 80);
}

                } catch(e){ console.error(e); openAuthModal('signIn'); }
            } else {
                openAuthModal('signUp');
            }
            
            
            
        }
        window.openSettings = openSettings; 
        window.showFriendsList = showFriendsList; 
        window.showServerChannels = showServerChannels; 
        window.openDM = openDM; 
        window.openChannel = openChannel; 
        window.openAuthModal = openAuthModal; 
        window.closeModal = closeModal; 
        window.saveSettings = saveSettings;
        window.toggleFriendRequests = toggleFriendRequests;
        window.toggleRightSidebar = toggleRightSidebar;
        // Initialize boot
        checkLocalAuthAndBoot();

    </script>
</body>
</html>
tetrischat.txt
<script>
(function(){
  if (!window.firebase || !firebase.database) { console.warn('firebase missing'); return; }
  const dbRoot = db, onlineRoot = dbRoot.ref('onlineUsers'), CHAT_ROOT = dbRoot.ref('chat'),
        MSGS_REF = CHAT_ROOT.child('messages'), TYPING_REF = CHAT_ROOT.child('typing');

  /* small helpers */
  const $ = id => document.getElementById(id);
  const esc = s => String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  const now = ()=>Date.now();
  const uidFor = u => (typeof safeKey === 'function')? safeKey(u): encodeURIComponent(u||'');
  const MIN_W=180,MIN_H=120,ACTIVE_MS=15000,MAX_IMG_BYTES=220*1024,MAX_MSG_LOAD=200;
  const onlinePanel = $('tetris-online-panel'), chatPanel = $('tetris-chat-panel');

  /* geometry persistence (unchanged) */
  const saveGeom = (id,r)=>{ try{ localStorage.setItem('t_geom_'+id,JSON.stringify(r)); }catch(e){} };
  const loadGeom = id => { try{ const v=localStorage.getItem('t_geom_'+id); return v?JSON.parse(v):null }catch(e){return null} };
  const applyGeom = (panel,id)=>{ const g=loadGeom(id); if(!g) return; const s=panel.style; if(g.left!=null)s.left=g.left+'px'; if(g.top!=null)s.top=g.top+'px'; if(g.width)s.width=g.width+'px'; if(g.height)s.height=g.height+'px'; };


  /* draggable + resizable (unchanged) */
  function makeDraggableResizable(panel,id){
    const hdr = panel.querySelector('[data-drag-handle]'), res = panel.querySelector('.t-resize-handle');
    const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
    const start = (e,move,end)=>{ e.preventDefault(); const rect=panel.getBoundingClientRect(); const sx=e.clientX, sy=e.clientY; const offX=sx-rect.left, offY=sy-rect.top;
      function mm(ev){ ev.preventDefault(); move(ev,rect,offX,offY); }
      function up(ev){ try{ document.removeEventListener('pointermove',mm); document.removeEventListener('pointerup',up);}catch(e){} end(); }
      document.addEventListener('pointermove',mm); document.addEventListener('pointerup',up);
    };
    hdr?.addEventListener('pointerdown', e => start(e, (ev,rect,offX,offY)=>{ let left=ev.clientX-offX, top=ev.clientY-offY; left=clamp(left,8,window.innerWidth-rect.width-8); top=clamp(top,8,window.innerHeight-rect.height-8); panel.style.left=left+'px'; panel.style.top=top+'px'; panel.style.right='auto'; }, ()=>{ const r=panel.getBoundingClientRect(); saveGeom(id,{left:Math.round(r.left),top:Math.round(r.top),width:Math.round(r.width),height:Math.round(r.height)}); }));
    res?.addEventListener('pointerdown', e => start(e, (ev,rect)=>{ let w=rect.width+(ev.clientX-e.clientX), h=rect.height+(ev.clientY-e.clientY); w=clamp(w,MIN_W,window.innerWidth-24); h=clamp(h,MIN_H,window.innerHeight-24); panel.style.width=w+'px'; panel.style.height=h+'px'; }, ()=>{ const r=panel.getBoundingClientRect(); saveGeom(id,{left:Math.round(r.left),top:Math.round(r.top),width:Math.round(r.width),height:Math.round(r.height)}); }));
  }
  if (onlinePanel) makeDraggableResizable(onlinePanel,'online');
  if (chatPanel)  makeDraggableResizable(chatPanel,'chat');

  /* --- ONLINE PRESENCE & list (unchanged) --- */
  const listEl = $('t-online-list'), countEl = $('t-online-count');
  const players = {}; // key -> {root,dot,name,val}
  function mkPlayerEl(key,val){
    const root=document.createElement('div'); root.className='t-player'; root.dataset.key=key;
    const dot=document.createElement('span'); dot.className='t-dot'; dot.setAttribute('aria-hidden','true');
    const name=document.createElement('div'); name.textContent = val?.username||('#'+key); name.style.whiteSpace='nowrap'; name.style.overflow='hidden'; name.style.textOverflow='ellipsis'; name.style.maxWidth='150px';
    root.appendChild(dot); root.appendChild(name);
    return {root,dot,name,val};
  }
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  /*
  function refreshCount(){ countEl.textContent=String(Object.keys(players).length); listEl.style.display = Object.keys(players).length ? 'block' : 'none'; }
  function refreshPlayer(key){ const p=players[key]; if(!p) return; p.name.textContent = (p.val&&p.val.username) || key; const last = p.val?.lastActive||0; const active = last && (now()-last<=ACTIVE_MS); p.dot.classList.toggle('on',!!active); p.dot.classList.toggle('off',!active); }
  onlineRoot.on('child_added', snap => { const k=snap.key, v=snap.val()||{}; if(players[k]) { players[k].val=v; refreshPlayer(k); return; } const el=mkPlayerEl(k,v); el.val=v; players[k]=el; listEl.appendChild(el.root); refreshCount(); refreshPlayer(k); });
  onlineRoot.on('child_changed', snap => { const k=snap.key, v=snap.val()||{}; if(players[k]){ players[k].val=v; refreshPlayer(k); }});
  onlineRoot.on('child_removed', snap => { const k=snap.key; if(players[k]) try{ players[k].root.remove(); }catch(e){} delete players[k]; refreshCount(); });
  setInterval(()=>Object.keys(players).forEach(k=>refreshPlayer(k)),2000);
  */
  
  
  
  
  
  
  
  
  
  
  
  

  /* My presence management (unchanged) */
  let myKey=null, myRef=null, presenceInterval=null, mySession=null;
  async function startMyPresence(username){
    if(!username) return;
    try{
      myKey = uidFor(username);
      mySession = crypto.randomUUID ? crypto.randomUUID() : ('sess_'+Math.random().toString(36).slice(2,10));
      myRef = onlineRoot.child(myKey);
      await myRef.set({ username, lastActive: firebase.database.ServerValue.TIMESTAMP, session: mySession, meta: 'tetris-client' });
      try{ myRef.onDisconnect().remove(); }catch(e){}
      if(presenceInterval) clearInterval(presenceInterval);
      presenceInterval = setInterval(()=>{ try{ myRef.update({ lastActive: firebase.database.ServerValue.TIMESTAMP, session: mySession }).catch(()=>{}); }catch(e){} },5000);
    }catch(e){ console.warn('startMyPresence',e); }
  }
  async function stopMyPresence(){ try{ if(presenceInterval) clearInterval(presenceInterval); if(myRef){ await myRef.remove(); try{ myRef.onDisconnect().cancel(); }catch(e){} } }catch(e){ console.warn('stopMyPresence',e); } finally{ myKey=myRef=null; presenceInterval=null; } }

  const origSignedIn = window.onSignedIn;
  window.onSignedIn = function(...a){ try{ const user = (a && a[0]) ? a[0] : (CURRENT_USER?.username) || (typeof getLocalAuth==='function' && getLocalAuth()?.username); if(user) startMyPresence(user); }catch(e){} if(typeof origSignedIn==='function') try{ origSignedIn.apply(this,a); }catch(e){console.warn('onSignedIn wrapper',e)} };
  try{ const cu = (CURRENT_USER && CURRENT_USER.username) ? CURRENT_USER.username : (typeof getLocalAuth === 'function' && getLocalAuth()?.username); if(cu) startMyPresence(cu); }catch(e){}
  if(window.tetrisAuth?.signOut){ const orig=window.tetrisAuth.signOut; window.tetrisAuth.signOut = async function(...a){ try{ await stopMyPresence(); }catch(e){} return orig.apply(this,a); }; }
  window.addEventListener('beforeunload', ()=>{ try{ if(myRef) myRef.remove(); }catch(e){} });

  /* --- ENHANCED CHAT (password gated, bind UI, attach/detach) --- */
  const CHAT_PASSWORD = 'CoconutCaleb27', SESSION_KEY='t_chat_unlocked_v1', BIND_KEY='t_chat_bind_v1';
  const chatMessages = $('t-chat-messages'), chatInput = $('t-chat-input'), chatCount = $('t-chat-count'), chatFile = $('t-chat-file'), chatFileBtn = $('t-chat-filebtn'), chatSendBtn = $('t-chat-send'), chatTypingEl = $('t-chat-typing');
  // initialize boolean from sessionStorage so unlocking persists in same tab
  let chatUnlocked = false;
  let observersInstalled=false, mutationObserver=null, handlers={added:null,removed:null,typing:null,changed:null}, bindState = JSON.parse(sessionStorage.getItem(BIND_KEY)||'null') || {mode:'Slash',key:'/'};

  function createLockOverlay(){
    if($('t-chat-lock-overlay')) return;
    const ov = document.createElement('div'); ov.id='t-chat-lock-overlay';
    ov.style.padding = '10px';
    ov.style.marginTop = '50px';
    ov.innerHTML = `<div id="t-chat-lock-inner">
      <div style="font-weight:700;margin-bottom:6px">Enter chat password</div>
      <input id="t-chat-password" type="password" placeholder="password" aria-label="chat password" style="width:100%;margin-bottom:8px"/>
      <div style="display:flex;gap:8px;justify-content:center"><button id="t-chat-unlock">Unlock</button><button id="t-chat-unlock-cancel">Cancel</button></div>
      <div style="font-size:12px;opacity:.8;margin-top:8px">Enter password to access Chat.</div>
    </div>`;
    chatPanel.appendChild(ov);
    // event wiring
    $('t-chat-unlock').addEventListener('click', ()=>{ const pw=$('t-chat-password').value||''; if(pw===CHAT_PASSWORD){ chatUnlocked=true; sessionStorage.setItem(SESSION_KEY,'1'); removeLockOverlay(); attachChatListeners(); } else alert('Incorrect password'); });
    $('t-chat-unlock-cancel').addEventListener('click', ()=>{ $('t-chat-password').value=''; chatPanel.style.display='none'; });
    // focus
    setTimeout(()=>{ const pw=$('t-chat-password'); if(pw) pw.focus(); },50);
  }
  function removeLockOverlay(){ const el=$('t-chat-lock-overlay'); if(el) try{ el.remove(); }catch(e){} }

  function createBindControls(){
    if($('t-chat-bind-row')) return;
    const hdr = chatPanel.querySelector('.hdr'); if(!hdr) return;
    const row = document.createElement('div'); row.id='t-chat-bind-row'; row.innerHTML = `<select id="t-chat-bind-mode" title="Chat bind mode"><option>None</option><option>Slash</option><option>Enter</option><option>Custom</option></select><input id="t-chat-bind-key" maxlength="1" placeholder="K" style="width:32px;margin-left:6px"/>`;
    hdr.appendChild(row);
    const modeEl=$('t-chat-bind-mode'), keyEl=$('t-chat-bind-key');
    modeEl.value = bindState.mode || 'Slash'; keyEl.value = bindState.key && bindState.mode==='Custom' ? bindState.key : '';
    function saveBind(){ bindState.mode = modeEl.value; bindState.key = keyEl.value || bindState.key || '/'; sessionStorage.setItem(BIND_KEY,JSON.stringify(bindState)); }
    modeEl.addEventListener('change', ()=>{ keyEl.style.display = modeEl.value==='Custom' ? 'inline-block' : 'none'; saveBind(); });
    keyEl.addEventListener('input', ()=>{ if(keyEl.value.length>1) keyEl.value=keyEl.value.charAt(0); saveBind(); });
    keyEl.style.display = modeEl.value==='Custom' ? 'inline-block' : 'none';
  }

  /* emoji utilities (NEW) */
  const EMOJI_RECENTS_KEY = 't_recent_emojis';
  // small set of emojis and categories; expand at will
  const EMOJI_CATEGORIES = {
    'clock': { title: 'Recent', emojis: [] },
    'smileys': { title: 'Smileys', emojis: ['ðŸ˜€','ðŸ˜','ðŸ˜‚','ðŸ¤£','ðŸ™‚','ðŸ˜‰','ðŸ˜','ðŸ˜˜','ðŸ˜Ž','ðŸ¤”','ðŸ˜…','ðŸ˜­','ðŸ˜¡','ðŸ¤¯','ðŸ¤©','ðŸ¤','ðŸ‘','ðŸ‘Ž','ðŸ‘','ðŸ™Œ','ðŸ™','ðŸ¤ž','ðŸ’ª','ðŸŽ‰'] },
    'animals': { title: 'Animals', emojis: ['ðŸ¶','ðŸ±','ðŸ­','ðŸ¹','ðŸ°','ðŸ¦Š','ðŸ»','ðŸ¼','ðŸ¨','ðŸ¯','ðŸ¦','ðŸ®','ðŸ·','ðŸ¸','ðŸµ','ðŸ¦„'] },
    'food': { title: 'Food', emojis: ['ðŸ','ðŸŽ','ðŸŒ','ðŸ‰','ðŸ‡','ðŸ“','ðŸ”','ðŸŸ','ðŸ•','ðŸŒ­','ðŸ£','ðŸ©','ðŸª','ðŸ«'] },
    'objects': { title: 'Objects', emojis: ['ðŸ’¡','ðŸ””','ðŸ“Ž','âœ‚ï¸','ðŸ“·','ðŸ’»','ðŸ”‘','ðŸ“±','ðŸŽ§','âš™ï¸','ðŸ”‹','ðŸ“…'] },
    'symbols': { title: 'Symbols', emojis: ['â¤ï¸','ðŸ’›','ðŸ’š','ðŸ’™','ðŸ–¤','â­','ðŸ”¥','âœ¨','âš¡','â˜‚ï¸','âœ…','âŒ'] }
  };

  function getRecentEmojis(){
    try{
      const raw = localStorage.getItem(EMOJI_RECENTS_KEY) || '[]';
      const arr = JSON.parse(raw);
      return Array.isArray(arr) ? arr : [];
    }catch(e){ return []; }
  }
  function saveRecentEmoji(emoji){
    try{
      const arr = getRecentEmojis();
      const idx = arr.indexOf(emoji);
      if(idx !== -1) arr.splice(idx,1);
      arr.unshift(emoji);
      arr.splice(24); // keep a cap
      localStorage.setItem(EMOJI_RECENTS_KEY, JSON.stringify(arr));
    }catch(e){ console.warn('saveRecentEmoji failed', e); }
  }

  // encode emoji as firebase-safe key
  function encEmojiKey(emoji){
    try{
      return encodeURIComponent(emoji).replace(/\./g,'%2E');
    }catch(e){
      return btoa(String(emoji)).replace(/\=/g,'');
    }
  }
  function decEmojiKey(key){
    try{ return decodeURIComponent(key); }catch(e){ try{ return atob(key); }catch(err){ return key; } }
  }

  // Renders reaction area (for one message) given reactions object
  function renderReactionsContainer(msgKey, reactions){
    const container = document.createElement('div');
    container.className = 't-emoji-reactions';
    if(!reactions) return container;
    const username = (CURRENT_USER && CURRENT_USER.username) ? CURRENT_USER.username : (typeof getLocalAuth==='function' && getLocalAuth()?.username) || 'guest';
    const userKey = uidFor(username);
    Object.keys(reactions).forEach(enc => {
      const usersObj = reactions[enc] || {};
      const emoji = decEmojiKey(enc);
      const count = Object.keys(usersObj).length;
      if(count <= 0) return;
      const own = !!usersObj[userKey];
      const btn = document.createElement('button');
      btn.className = 't-emoji-reaction' + (own ? ' own' : '');
      btn.title = `${count} reacted`;
      btn.innerHTML = `<span style="font-size:18px;line-height:1">${emoji}</span><span style="font-size:12px;opacity:.9">${count}</span>`;
      btn.addEventListener('click', ev => { ev.stopPropagation(); toggleReaction(msgKey, emoji); });
      container.appendChild(btn);
    });
    return container;
  }

  // toggle reaction via firebase transaction
  async function toggleReaction(msgKey, emoji){
    try{
      if(!msgKey) return;
      if(!chatUnlocked){ createLockOverlay(); alert('Unlock chat first'); return; }
      const username = (CURRENT_USER && CURRENT_USER.username) ? CURRENT_USER.username : (typeof getLocalAuth==='function' && getLocalAuth()?.username) || 'guest';
      const userKey = uidFor(username);
      const enc = encEmojiKey(emoji);
      const ref = MSGS_REF.child(msgKey).child('reactions').child(enc);
      await ref.transaction(current => {
        current = current || {};
        if(current[userKey]) {
          delete current[userKey];
        } else {
          current[userKey] = true;
        }
        if(Object.keys(current).length === 0) return null;
        return current;
      });
      // update recents locally
      saveRecentEmoji(emoji);
    }catch(e){ console.warn('toggleReaction failed', e); }
  }

  // Create or update a message DOM element (modified to include reactions + react button)
  function addChatMessageToDOM(k,msg){
    if(!chatMessages || !msg || !chatUnlocked) return;
    if(document.getElementById('msg_'+k)) return; // already present
    const local = (CURRENT_USER?.username) || (typeof getLocalAuth==='function' && getLocalAuth()?.username);
    const isOwn = msg.username && local && String(msg.username)===String(local);
    const el = document.createElement('div'); el.id='msg_'+k; el.className='t-chat-msg '+(isOwn?'own':'other');
    const meta = document.createElement('div'); meta.className='t-chat-meta';
    const name = document.createElement('strong'); name.textContent = esc(msg.username||'anon');
    const time = document.createElement('span'); time.style.marginLeft='6px'; time.style.opacity='.8'; time.textContent = ' â€¢ ' + new Date((msg.ts && typeof msg.ts==='number')?msg.ts:Date.now()).toLocaleTimeString();
    meta.appendChild(name); meta.appendChild(time);

    // delete button for own messages
    if(isOwn){ const del=document.createElement('button'); del.className='t-msg-delete'; del.title='Delete message'; del.textContent='Delete'; del.addEventListener('click', async ev=>{ ev.stopPropagation(); if(!confirm('Delete this message?')) return; try{ await MSGS_REF.child(k).remove(); }catch(e){ console.warn('del failed',e); } }); meta.appendChild(del); }

    // reaction area
    const reactionWrap = document.createElement('div'); reactionWrap.style.display='flex'; reactionWrap.style.alignItems='center'; reactionWrap.style.gap='6px';

    // react button to open picker anchored to this message
    const reactBtn = document.createElement('button'); reactBtn.className='t-react-btn'; reactBtn.textContent='React';
    reactBtn.addEventListener('click', ev => {
      ev.stopPropagation();
      if(!chatUnlocked){ createLockOverlay(); alert('Unlock chat first'); return; }
      openEmojiPicker({ anchorEl: reactBtn, onPick: (emoji)=>{ toggleReaction(k, emoji); closeEmojiPicker(); }, preferCategory: 'clock' });
    });
    reactionWrap.appendChild(reactBtn);

    meta.appendChild(reactionWrap);

    const body = document.createElement('div'); body.className='t-chat-body';
    if(msg.text) body.innerHTML = esc(msg.text).replace(/\n/g,'<br>');
    if(msg.image){ const img=document.createElement('img'); img.className='t-chat-img'; img.src=msg.image; img.alt=(msg.username||'')+' image'; body.appendChild(img); }

    el.appendChild(meta);
    el.appendChild(body);

    // render reactions (if any)
    const reactionsNode = msg.reactions || null;
    const reactionsContainer = renderReactionsContainer(k, reactionsNode);
    if(reactionsContainer && reactionsContainer.children.length) el.appendChild(reactionsContainer);

    chatMessages.appendChild(el);
    chatMessages.scrollTop=chatMessages.scrollHeight;
    while(chatMessages.children.length>500) chatMessages.removeChild(chatMessages.firstChild);
  }

  /* attach/detach DB listeners for messages & typing */
  function attachChatListeners(){
    if(observersInstalled) return; // already attached
    if(!chatUnlocked){ createLockOverlay(); return; }
    observersInstalled=true;
    handlers.added = snap => { const k=snap.key, v=snap.val()||{}; if(v.ts && typeof v.ts==='object' && v.ts['.sv']) v.ts = Date.now(); addChatMessageToDOM(k,v); };
    handlers.removed = snap => { const el=document.getElementById('msg_'+snap.key); if(el) try{ el.remove(); }catch(e){} };
    // NEW: child_changed to reflect live reaction updates or edits
    handlers.changed = snap => { const k=snap.key, v=snap.val()||{}; const el = document.getElementById('msg_'+k); if(!el) {
        // if not currently present (maybe scrolled out) add it
        addChatMessageToDOM(k,v); return;
      }
      // update body text / image if changed
      const body = el.querySelector('.t-chat-body');
      if(body){
        body.innerHTML = '';
        if(v.text) body.innerHTML = esc(v.text).replace(/\n/g,'<br>');
        if(v.image){ const img=document.createElement('img'); img.className='t-chat-img'; img.src=v.image; img.alt=(v.username||'')+' image'; body.appendChild(img); }
      }
      // update reactions area
      const oldReactions = el.querySelector('.t-emoji-reactions');
      if(oldReactions) oldReactions.remove();
      const newReactions = renderReactionsContainer(k, v.reactions || null);
      if(newReactions && newReactions.children.length) el.appendChild(newReactions);
    };
    handlers.typing = snap => { const m = snap.val()||{}; const names = Object.keys(m).filter(k=>!!m[k]); if(!names.length){ if(chatTypingEl) chatTypingEl.textContent=''; return; } const display = names.map(k=>decodeURIComponent(k)).slice(0,3); chatTypingEl.textContent = display.length===1?`${display[0]} is typingâ€¦`:(display.length===2?`${display[0]} & ${display[1]} are typingâ€¦`:`${display.slice(0,2).join(' & ')} are typingâ€¦`); };
    try{ MSGS_REF.limitToLast(MAX_MSG_LOAD).on('child_added',handlers.added); MSGS_REF.on('child_removed',handlers.removed); MSGS_REF.on('child_changed', handlers.changed); TYPING_REF.on('value',handlers.typing); }catch(e){ console.warn('attachChatListeners failed',e); }
    if(!mutationObserver){ mutationObserver = new MutationObserver(()=>{ if(!document.body.contains(chatPanel)){ console.warn('chat panel removed â€” detaching listeners'); stopChatListeners(); } }); mutationObserver.observe(document.body,{childList:true,subtree:true}); }
  }

  // detach but DO NOT create lock overlay or clear session key (used on hide)
  function stopChatListeners(){
    if(!observersInstalled) return;
    try{
      if(handlers.added) MSGS_REF.off('child_added',handlers.added);
      if(handlers.removed) MSGS_REF.off('child_removed',handlers.removed);
      if(handlers.changed) MSGS_REF.off('child_changed',handlers.changed);
      if(handlers.typing) TYPING_REF.off('value',handlers.typing);
    }catch(e){ console.warn('stopChatListeners error',e); }
    observersInstalled=false;
    handlers={added:null,removed:null,typing:null,changed:null};
    if(chatMessages) chatMessages.innerHTML='';
    if(chatTypingEl) chatTypingEl.textContent='';
    try{ if(mutationObserver){ mutationObserver.disconnect(); mutationObserver=null; } }catch(e){}
  }

  // original detach which fully locks chat
  function detachChatListeners(){
    if(!observersInstalled) return;
    try{ if(handlers.added) MSGS_REF.off('child_added',handlers.added); if(handlers.removed) MSGS_REF.off('child_removed',handlers.removed); if(handlers.changed) MSGS_REF.off('child_changed',handlers.changed); if(handlers.typing) TYPING_REF.off('value',handlers.typing); }catch(e){ console.warn('detach error',e); }
    handlers={added:null,removed:null,typing:null,changed:null}; if(chatMessages) chatMessages.innerHTML=''; if(chatTypingEl) chatTypingEl.textContent=''; sessionStorage.removeItem(SESSION_KEY); chatUnlocked=false; createLockOverlay();
    try{ if(mutationObserver){ mutationObserver.disconnect(); mutationObserver=null; } }catch(e){}
  }

  // Paste this inside the same IIFE (where MSGS_REF, chatInput, chatUnlocked, createLockOverlay exist)
  async function sendMessage(text, image){
    try{
      if (!chatUnlocked) { createLockOverlay(); alert('Unlock chat first'); return; }
      const txt = String(text || '').slice(0,500);
      if (!txt && !image) { return; } // nothing to send

      const username = (CURRENT_USER && CURRENT_USER.username) ? CURRENT_USER.username : (typeof getLocalAuth==='function' && getLocalAuth()?.username) || 'guest';
      const payload = {
        username,
        ts: firebase.database.ServerValue.TIMESTAMP
      };
      if (txt) payload.text = txt;
      if (image) payload.image = image;

      // push the message
      await MSGS_REF.push(payload);

      // reset UI
      if (chatInput) { chatInput.value = ''; chatCount.textContent = '0/500'; }
      setTyping(false);
    }catch(err){
      console.error('sendMessage failed', err);
      alert('Failed to send message: ' + (err && err.message));
    }
  }
  // expose globally (optional)
  window.sendMessage = sendMessage;


  /* chat focus blocking */
  function onChatFocus(){ window.chatFocused=true; try{ tetrisChat?.setTyping?.(true); }catch(e){} }
  function onChatBlur(){ window.chatFocused=false; try{ tetrisChat?.setTyping?.(false); }catch(e){} }
  chatInput?.addEventListener('focus', onChatFocus); chatInput?.addEventListener('blur', onChatBlur);

  /* Send & file wiring (respect lock) */
  $('t-chat-filebtn')?.addEventListener('click', ev=>{ if(!chatUnlocked){ ev.preventDefault(); alert('Unlock chat first'); createLockOverlay(); return; } chatFile?.click(); });

  // NEW: Emoji button next to file attach opens picker for inserting into input
  const emojiBtn = $('t-chat-emoji-btn');
  emojiBtn?.addEventListener('click', ev=>{
    ev.stopPropagation();
    if(!chatUnlocked){ createLockOverlay(); alert('Unlock chat first'); return; }
    openEmojiPicker({ anchorEl: emojiBtn, onPick: (emoji)=>{ insertEmojiAtCaret(chatInput, emoji); saveRecentEmoji(emoji); closeEmojiPicker(); }, preferCategory: 'clock' });
  });

  chatSendBtn?.addEventListener('click', ev=>{ if(!chatUnlocked){ ev.preventDefault(); alert('Unlock chat first'); createLockOverlay(); return; } if(typeof sendMessage==='function') sendMessage(chatInput.value, null); else chatSendBtn.closest('form')?.submit?.(); });

  /* global key bind */
  function globalKeyHandler(ev){
    const active=document.activeElement;
    if(active && (active.tagName==='INPUT' || active.tagName==='TEXTAREA' || active.isContentEditable)) return;
    const mode = bindState.mode || 'Slash'; let bindKey = bindState.key || '/';
    if(mode==='Slash') bindKey='/'; else if(mode==='Enter') bindKey='Enter';
    if(mode==='None') return;
    if((bindKey==='Enter' && ev.key==='Enter') || (bindKey.length===1 && ev.key===bindKey) || (bindKey==='/' && ev.key==='/')){
      ev.preventDefault();
      if(!chatUnlocked){ createLockOverlay(); const pw=$('t-chat-password'); if(pw) pw.focus(); return; }
      chatInput?.focus();
    }
  }
  document.addEventListener('keydown', globalKeyHandler, {capture:true});

  /* clear button */
  $('t-chat-clear')?.addEventListener('click', ()=>{ if(chatMessages) chatMessages.innerHTML=''; });

  /* image processing helper (unchanged) */
  function imageFileToDataURL(file, maxWidth=800, quality=0.72){
    return new Promise((resolve,reject)=>{
      try{
        const r=new FileReader();
        r.onerror = e => reject(e);
        r.onload = ()=>{
          const img=new Image();
          img.onerror = e => reject(e);
          img.onload = ()=>{
            const scale = Math.min(1, maxWidth / img.width);
            const w = Math.round(img.width * scale), h = Math.round(img.height * scale);
            const c=document.createElement('canvas'); c.width=w; c.height=h; const ctx=c.getContext('2d'); ctx.drawImage(img,0,0,w,h);
            function hasAlpha(){
              try{
                const total=w*h, max=1000, step=Math.max(1,Math.floor(Math.sqrt(total/max)));
                const data=ctx.getImageData(0,0,w,h).data;
                for(let y=0;y<h;y+=step) for(let x=0;x<w;x+=step){ const idx=(y*w+x)*4; if(data[idx+3]!==255) return true; }
                return false;
              }catch(err){ return file && file.type==='image/png'; }
            }
            const needsAlpha = hasAlpha();
            resolve(needsAlpha?c.toDataURL('image/png'):c.toDataURL('image/jpeg',quality));
          };
          img.src = r.result;
        };
        r.readAsDataURL(file);
      }catch(e){ reject(e); }
    });
  }

  /* file handling */
  chatFile?.addEventListener('change', async ev=>{
    if(!chatUnlocked){ chatFile.value=''; alert('Unlock chat first'); createLockOverlay(); return; }
    const f = chatFile.files && chatFile.files[0]; if(!f) return; if(!f.type.startsWith('image/')){ alert('Only images allowed'); chatFile.value=''; return; }
    try{
      let dataURL = await imageFileToDataURL(f,800,0.72);
      let bytes = Math.round((dataURL.length*3)/4);
      if(bytes > MAX_IMG_BYTES){
        const smaller = await imageFileToDataURL(f,600,0.6);
        const b2 = Math.round((smaller.length*3)/4);
        if(b2 > MAX_IMG_BYTES){ if(!confirm('Image is still large and may fail to store. Continue?')) { chatFile.value=''; return; } }
        if(typeof sendMessage==='function') await sendMessage(chatInput.value, smaller);
      } else { if(typeof sendMessage==='function') await sendMessage(chatInput.value, dataURL); }
    }catch(e){ console.warn('image processing failed',e); alert('Image processing failed. Try a smaller image.'); }
    finally{ chatFile.value=''; }
  });

  /* typing indicator */
  let typingTimer=null;
  function setTyping(state){
    try{
      const username = (CURRENT_USER && CURRENT_USER.username) ? CURRENT_USER.username : (typeof getLocalAuth==='function' && getLocalAuth()?.username) || 'guest';
      const key = uidFor(username);
      if(!key) return;
      const TR = TYPING_REF;
      if(state){
        TR.child(key).set(true);
        if(typingTimer) clearTimeout(typingTimer);
        typingTimer = setTimeout(()=>{ TR.child(key).set(false); typingTimer=null; },2000);
      } else {
        TR.child(key).set(false);
        if(typingTimer) { clearTimeout(typingTimer); typingTimer=null; }
      }
    }catch(e){ console.warn('setTyping failed',e); }
  }

  /* tie typing to input */
  chatInput?.addEventListener('input', e=>{ chatCount.textContent = `${e.target.value.length}/500`; setTyping(true); });
  chatInput?.addEventListener('keydown', e=>{ if(e.key==='Enter' && (e.ctrlKey||e.metaKey)) return; if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); chatSendBtn?.click(); } });

  /* --- new: stopChatListeners defined above --- */

  /* attach/detach init */
  function init(){ if(!chatUnlocked){ createLockOverlay(); if(chatMessages) chatMessages.innerHTML=''; } else { removeLockOverlay(); attachChatListeners(); } }
  init();

  // hookup the 'X' close button to hide chat + remove clear button + stop listeners
  const chatCloseBtn = $('t-chat-close');
  chatCloseBtn?.addEventListener('click', ()=>{
    try{
      const clearBtn = $('t-chat-clear');
      if(clearBtn) clearBtn.remove();
      // stop fetching messages/typing
      stopChatListeners();
      // hide panel
      if(chatPanel) chatPanel.style.display = 'none';
    }catch(e){ console.warn('chat close failed',e); }
  });

  window.tetrisChatEnhance = { attachChatListeners, detachChatListeners, stopChatListeners, isUnlocked: ()=>chatUnlocked, setTyping };

  window.addEventListener('beforeunload', ()=>{ try{ setTyping(false); }catch(e){} });

  /* --- SPACE-FIX: ensure inputs accept actual spaces when game captures space globally --- */
  (function(){
    function insertSpaceAtCaret(target){
      try{
        if(!target||target.readOnly||target.disabled) return;
        const start = typeof target.selectionStart==='number' ? target.selectionStart : target.value.length;
        const end = typeof target.selectionEnd==='number' ? target.selectionEnd : start;
        const val = target.value || '';
        const newVal = val.slice(0,start) + ' ' + val.slice(end);
        target.value = newVal;
        const pos = start + 1;
        target.selectionStart = target.selectionEnd = pos;
        target.dispatchEvent(new Event('input',{bubbles:true}));
      }catch(e){ console.warn('insertSpaceAtCaret error',e); }
    }
    function attachSpaceFix(el){
      if(!el) return;
      el.addEventListener('keydown', function(ev){
        if(ev.key===' '||ev.code==='Space'){ try{ insertSpaceAtCaret(ev.target); }catch(e){} try{ ev.stopImmediatePropagation(); }catch(e){} try{ ev.preventDefault(); }catch(e){} }
      }, {capture:true,passive:false});
      el.addEventListener('focus', ()=>{
        function docCap(ev){ if(ev.key===' '||ev.code==='Space'){ try{ ev.stopImmediatePropagation(); }catch(e){} } }
        document.addEventListener('keydown', docCap, {capture:true,passive:false});
        el.addEventListener('blur', ()=>{ document.removeEventListener('keydown', docCap, {capture:true}); }, {once:true});
      });
    }
    function runWhenReady(){
      attachSpaceFix(document.getElementById('tetris-username'));
      attachSpaceFix($('t-chat-input'));
      document.addEventListener('focusin', e=>{ const t=e.target; if(!t) return; if(t.tagName==='INPUT'||t.tagName==='TEXTAREA'||t.isContentEditable) attachSpaceFix(t); });
    }
    if(document.readyState==='complete'||document.readyState==='interactive') runWhenReady(); else document.addEventListener('DOMContentLoaded', runWhenReady);
  })();

  /* ----------------- EMOJI PICKER UI (NEW) ----------------- */
  let emojiPickerEl = null;
  function closeEmojiPicker(){
    try{ if(emojiPickerEl){ emojiPickerEl.remove(); emojiPickerEl=null; } }catch(e){}
  }
  function positionPicker(anchorEl, pickerEl){
    if(!anchorEl || !pickerEl) return;
    const rect = anchorEl.getBoundingClientRect();
    // try place below anchor; if not enough space, place above
    const topBelow = rect.bottom + 8;
    const above = rect.top - pickerEl.offsetHeight - 8;
    let top = topBelow;
    if(top + pickerEl.offsetHeight > window.innerHeight - 8) {
      top = Math.max(8, above);
    }
    let left = rect.left;
    if(left + pickerEl.offsetWidth > window.innerWidth - 8) {
      left = window.innerWidth - pickerEl.offsetWidth - 8;
    }
    pickerEl.style.left = Math.round(left) + 'px';
    pickerEl.style.top = Math.round(top) + 'px';
  }

  // insert emoji into input at caret
  function insertEmojiAtCaret(inputEl, emoji){
    try{
      if(!inputEl) return;
      const start = typeof inputEl.selectionStart === 'number' ? inputEl.selectionStart : inputEl.value.length;
      const end = typeof inputEl.selectionEnd === 'number' ? inputEl.selectionEnd : start;
      const val = inputEl.value || '';
      inputEl.value = val.slice(0,start) + emoji + val.slice(end);
      const caret = start + emoji.length;
      inputEl.selectionStart = inputEl.selectionEnd = caret;
      inputEl.focus();
      inputEl.dispatchEvent(new Event('input',{bubbles:true}));
    }catch(e){ console.warn('insertEmojiAtCaret', e); }
  }

  function openEmojiPicker({ anchorEl=null, onPick=null, preferCategory='clock' } = {}){
    closeEmojiPicker();
    emojiPickerEl = document.createElement('div');
    emojiPickerEl.className = 't-emoji-picker';
    emojiPickerEl.setAttribute('role','dialog');
    // tabs
    const tabs = document.createElement('div'); tabs.className='t-emoji-tabs';
    const categories = Object.keys(EMOJI_CATEGORIES);
    categories.forEach(cat => {
      const btn = document.createElement('button');
      btn.className = 't-emoji-tab';
      btn.textContent = EMOJI_CATEGORIES[cat].title || cat;
      btn.addEventListener('click', ()=> {
        buildGrid(cat);
      });
      tabs.appendChild(btn);
    });
    emojiPickerEl.appendChild(tabs);
    const grid = document.createElement('div'); grid.className = 't-emoji-grid';
    emojiPickerEl.appendChild(grid);

    document.body.appendChild(emojiPickerEl);
    // build grid for initial category (prefer recent/clock)
    function buildGrid(cat){
      grid.innerHTML = '';
      let emojis = [];
      if(cat === 'clock'){
        emojis = getRecentEmojis();
        if(!emojis || emojis.length===0) {
          // fall back to smileys if none
          emojis = EMOJI_CATEGORIES['smileys'].emojis.slice(0,24);
        }
      } else {
        emojis = (EMOJI_CATEGORIES[cat] && EMOJI_CATEGORIES[cat].emojis) ? EMOJI_CATEGORIES[cat].emojis : [];
      }
      emojis.forEach(emo => {
        const c = document.createElement('div');
        c.className = 't-emoji-cell';
        c.textContent = emo;
        c.title = emo;
        c.addEventListener('click', ev => {
          ev.stopPropagation();
          try{ if(typeof onPick === 'function') onPick(emo); }catch(e){ console.warn('emoji onPick error',e); }
          saveRecentEmoji(emo);
        });
        grid.appendChild(c);
      });
    }

    // initial tab pick
    if(preferCategory && categories.includes(preferCategory)) buildGrid(preferCategory);
    else buildGrid(categories[0]);

    // position near anchor
    setTimeout(()=>{ positionPicker(anchorEl || emojiBtn, emojiPickerEl); },20);

    // close on outside click or ESC
    function onDocClick(ev){
      if(!emojiPickerEl) return;
      if(ev.target && emojiPickerEl.contains(ev.target)) return;
      closeEmojiPicker();
      document.removeEventListener('pointerdown', onDocClick, true);
      document.removeEventListener('keydown', onEsc, true);
    }
    function onEsc(ev){
      if(ev.key === 'Escape'){ closeEmojiPicker(); document.removeEventListener('pointerdown', onDocClick, true); document.removeEventListener('keydown', onEsc, true); }
    }
    document.addEventListener('pointerdown', onDocClick, true);
    document.addEventListener('keydown', onEsc, true);
  }

  // close when window resizes to avoid floating leftovers
  window.addEventListener('resize', ()=>closeEmojiPicker());



  /* ----------------- END EMOJI PICKER UI ----------------- */

})();
</script>
